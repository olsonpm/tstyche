// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`toBeCallableWith default parameters: stderr 1`] = `
"Error: Expression can be called without arguments.

  12 |   test("expression can be called without arguments", () => {
  13 |     expect(first).type.toBeCallableWith();
> 14 |     expect(first).type.not.toBeCallableWith();
     |                            ^
  15 |   });
  16 | 
  17 |   test("expression requires at least 1 argument", () => {

       at ./__typetests__/default-parameters.tst.ts:14:28 ❭ when target is a value ❭ expression can be called without arguments

Error: Expression requires at least 1 argument.

  17 |   test("expression requires at least 1 argument", () => {
  18 |     expect(second).type.not.toBeCallableWith();
> 19 |     expect(second).type.toBeCallableWith();
     |                         ^
  20 |   });
  21 | 
  22 |   test("expression can be called with provided argument", () => {

       at ./__typetests__/default-parameters.tst.ts:19:25 ❭ when target is a value ❭ expression requires at least 1 argument

Error: Expression can be called with provided argument.

  22 |   test("expression can be called with provided argument", () => {
  23 |     expect(first).type.toBeCallableWith(undefined);
> 24 |     expect(first).type.not.toBeCallableWith(undefined);
     |                            ^
  25 | 
  26 |     expect(first).type.toBeCallableWith("one");
  27 |     expect(first).type.not.toBeCallableWith("one");

       at ./__typetests__/default-parameters.tst.ts:24:28 ❭ when target is a value ❭ expression can be called with provided argument

Error: Expression can be called with provided argument.

  25 | 
  26 |     expect(first).type.toBeCallableWith("one");
> 27 |     expect(first).type.not.toBeCallableWith("one");
     |                            ^
  28 | 
  29 |     expect(second).type.toBeCallableWith("one");
  30 |     expect(second).type.not.toBeCallableWith("one");

       at ./__typetests__/default-parameters.tst.ts:27:28 ❭ when target is a value ❭ expression can be called with provided argument

Error: Expression can be called with provided argument.

  28 | 
  29 |     expect(second).type.toBeCallableWith("one");
> 30 |     expect(second).type.not.toBeCallableWith("one");
     |                             ^
  31 |   });
  32 | 
  33 |   test("expression can be called with provided arguments", () => {

       at ./__typetests__/default-parameters.tst.ts:30:29 ❭ when target is a value ❭ expression can be called with provided argument

Error: Expression can be called with provided arguments.

  33 |   test("expression can be called with provided arguments", () => {
  34 |     expect(second).type.toBeCallableWith("one", undefined);
> 35 |     expect(second).type.not.toBeCallableWith("one", undefined);
     |                             ^
  36 | 
  37 |     expect(second).type.toBeCallableWith("one", 123);
  38 |     expect(second).type.not.toBeCallableWith("one", 123);

       at ./__typetests__/default-parameters.tst.ts:35:29 ❭ when target is a value ❭ expression can be called with provided arguments

Error: Expression can be called with provided arguments.

  36 | 
  37 |     expect(second).type.toBeCallableWith("one", 123);
> 38 |     expect(second).type.not.toBeCallableWith("one", 123);
     |                             ^
  39 |   });
  40 | 
  41 |   test("expression takes at most 1 argument", () => {

       at ./__typetests__/default-parameters.tst.ts:38:29 ❭ when target is a value ❭ expression can be called with provided arguments

Error: Expression takes at most 1 argument.

  41 |   test("expression takes at most 1 argument", () => {
  42 |     expect(first).type.not.toBeCallableWith("one", "two");
> 43 |     expect(first).type.toBeCallableWith("one", "two");
     |                        ^
  44 |   });
  45 | 
  46 |   test("expression takes at most 2 arguments", () => {

       at ./__typetests__/default-parameters.tst.ts:43:24 ❭ when target is a value ❭ expression takes at most 1 argument

Error: Expression takes at most 2 arguments.

  46 |   test("expression takes at most 2 arguments", () => {
  47 |     expect(second).type.not.toBeCallableWith("one", 123, true);
> 48 |     expect(second).type.toBeCallableWith("one", 123, true);
     |                         ^
  49 |   });
  50 | 
  51 |   test("type expression can be called without arguments", () => {

       at ./__typetests__/default-parameters.tst.ts:48:25 ❭ when target is a value ❭ expression takes at most 2 arguments

Error: Type expression can be called without arguments.

  51 |   test("type expression can be called without arguments", () => {
  52 |     expect<(a?: string) => void>().type.toBeCallableWith();
> 53 |     expect<(a?: string) => void>().type.not.toBeCallableWith();
     |                                             ^
  54 |   });
  55 | 
  56 |   test("type expression requires at least 1 argument", () => {

       at ./__typetests__/default-parameters.tst.ts:53:45 ❭ when target is a value ❭ type expression can be called without arguments

Error: Type expression requires at least 1 argument.

  56 |   test("type expression requires at least 1 argument", () => {
  57 |     expect<(a: string, b?: number) => void>().type.not.toBeCallableWith();
> 58 |     expect<(a: string, b?: number) => void>().type.toBeCallableWith();
     |                                                    ^
  59 |   });
  60 | 
  61 |   test("type expression can be called with provided argument", () => {

       at ./__typetests__/default-parameters.tst.ts:58:52 ❭ when target is a value ❭ type expression requires at least 1 argument

Error: Type expression can be called with provided argument.

  61 |   test("type expression can be called with provided argument", () => {
  62 |     expect<(a?: string) => void>().type.toBeCallableWith(undefined);
> 63 |     expect<(a?: string) => void>().type.not.toBeCallableWith(undefined);
     |                                             ^
  64 | 
  65 |     expect<(a?: string) => void>().type.toBeCallableWith("one");
  66 |     expect<(a?: string) => void>().type.not.toBeCallableWith("one");

       at ./__typetests__/default-parameters.tst.ts:63:45 ❭ when target is a value ❭ type expression can be called with provided argument

Error: Type expression can be called with provided argument.

  64 | 
  65 |     expect<(a?: string) => void>().type.toBeCallableWith("one");
> 66 |     expect<(a?: string) => void>().type.not.toBeCallableWith("one");
     |                                             ^
  67 | 
  68 |     expect<(a: string, b?: number) => void>().type.toBeCallableWith("one");
  69 |     expect<(a: string, b?: number) => void>().type.not.toBeCallableWith("one");

       at ./__typetests__/default-parameters.tst.ts:66:45 ❭ when target is a value ❭ type expression can be called with provided argument

Error: Type expression can be called with provided argument.

  67 | 
  68 |     expect<(a: string, b?: number) => void>().type.toBeCallableWith("one");
> 69 |     expect<(a: string, b?: number) => void>().type.not.toBeCallableWith("one");
     |                                                        ^
  70 |   });
  71 | 
  72 |   test("expression can be called with provided arguments", () => {

       at ./__typetests__/default-parameters.tst.ts:69:56 ❭ when target is a value ❭ type expression can be called with provided argument

Error: Type expression can be called with provided arguments.

  72 |   test("expression can be called with provided arguments", () => {
  73 |     expect<(a: string, b?: number) => void>().type.toBeCallableWith("one", undefined);
> 74 |     expect<(a: string, b?: number) => void>().type.not.toBeCallableWith("one", undefined);
     |                                                        ^
  75 | 
  76 |     expect<(a: string, b?: number) => void>().type.toBeCallableWith("one", 123);
  77 |     expect<(a: string, b?: number) => void>().type.not.toBeCallableWith("one", 123);

       at ./__typetests__/default-parameters.tst.ts:74:56 ❭ when target is a value ❭ expression can be called with provided arguments

Error: Type expression can be called with provided arguments.

  75 | 
  76 |     expect<(a: string, b?: number) => void>().type.toBeCallableWith("one", 123);
> 77 |     expect<(a: string, b?: number) => void>().type.not.toBeCallableWith("one", 123);
     |                                                        ^
  78 |   });
  79 | 
  80 |   test("type expression takes at most 1 argument", () => {

       at ./__typetests__/default-parameters.tst.ts:77:56 ❭ when target is a value ❭ expression can be called with provided arguments

Error: Type expression takes at most 1 argument.

  80 |   test("type expression takes at most 1 argument", () => {
  81 |     expect<(a?: string) => void>().type.not.toBeCallableWith("one", "two");
> 82 |     expect<(a?: string) => void>().type.toBeCallableWith("one", "two");
     |                                         ^
  83 |   });
  84 | 
  85 |   test("expression takes at most 2 arguments", () => {

       at ./__typetests__/default-parameters.tst.ts:82:41 ❭ when target is a value ❭ type expression takes at most 1 argument

Error: Type expression takes at most 2 arguments.

  85 |   test("expression takes at most 2 arguments", () => {
  86 |     expect<(a: string, b?: number) => void>().type.not.toBeCallableWith("one", 123, true);
> 87 |     expect<(a: string, b?: number) => void>().type.toBeCallableWith("one", 123, true);
     |                                                    ^
  88 |   });
  89 | });
  90 | 

       at ./__typetests__/default-parameters.tst.ts:87:52 ❭ when target is a value ❭ expression takes at most 2 arguments

Error: Expression can be called without arguments.

  92 |   test("expression can be called without arguments", () => {
  93 |     expect(first).type.toBeCallableWith<[]>();
> 94 |     expect(first).type.not.toBeCallableWith<[]>();
     |                            ^
  95 |   });
  96 | 
  97 |   test("expression requires at least 1 argument", () => {

       at ./__typetests__/default-parameters.tst.ts:94:28 ❭ when target is a type ❭ expression can be called without arguments

Error: Expression requires at least 1 argument.

   97 |   test("expression requires at least 1 argument", () => {
   98 |     expect(second).type.not.toBeCallableWith<[]>();
>  99 |     expect(second).type.toBeCallableWith<[]>();
      |                         ^
  100 | 
  101 |     expect(second).type.not.toBeCallableWith<[a?: "one"]>();
  102 |     expect(second).type.toBeCallableWith<[a?: "one"]>();

        at ./__typetests__/default-parameters.tst.ts:99:25 ❭ when target is a type ❭ expression requires at least 1 argument

Error: Expression requires at least 1 argument.

  100 | 
  101 |     expect(second).type.not.toBeCallableWith<[a?: "one"]>();
> 102 |     expect(second).type.toBeCallableWith<[a?: "one"]>();
      |                         ^
  103 | 
  104 |     expect(second).type.not.toBeCallableWith<[a?: "one", b?: 123]>();
  105 |     expect(second).type.toBeCallableWith<[a?: "one", b?: 123]>();

        at ./__typetests__/default-parameters.tst.ts:102:25 ❭ when target is a type ❭ expression requires at least 1 argument

Error: Expression requires at least 1 argument.

  103 | 
  104 |     expect(second).type.not.toBeCallableWith<[a?: "one", b?: 123]>();
> 105 |     expect(second).type.toBeCallableWith<[a?: "one", b?: 123]>();
      |                         ^
  106 |   });
  107 | 
  108 |   test("expression can be called with provided argument", () => {

        at ./__typetests__/default-parameters.tst.ts:105:25 ❭ when target is a type ❭ expression requires at least 1 argument

Error: Expression can be called with provided argument.

  108 |   test("expression can be called with provided argument", () => {
  109 |     expect(first).type.toBeCallableWith<[undefined]>();
> 110 |     expect(first).type.not.toBeCallableWith<[undefined]>();
      |                            ^
  111 | 
  112 |     expect(first).type.toBeCallableWith<["one"]>();
  113 |     expect(first).type.not.toBeCallableWith<["one"]>();

        at ./__typetests__/default-parameters.tst.ts:110:28 ❭ when target is a type ❭ expression can be called with provided argument

Error: Expression can be called with provided argument.

  111 | 
  112 |     expect(first).type.toBeCallableWith<["one"]>();
> 113 |     expect(first).type.not.toBeCallableWith<["one"]>();
      |                            ^
  114 | 
  115 |     expect(first).type.toBeCallableWith<[a: undefined]>();
  116 |     expect(first).type.not.toBeCallableWith<[a: undefined]>();

        at ./__typetests__/default-parameters.tst.ts:113:28 ❭ when target is a type ❭ expression can be called with provided argument

Error: Expression can be called with provided argument.

  114 | 
  115 |     expect(first).type.toBeCallableWith<[a: undefined]>();
> 116 |     expect(first).type.not.toBeCallableWith<[a: undefined]>();
      |                            ^
  117 | 
  118 |     expect(first).type.toBeCallableWith<[a?: "one"]>();
  119 |     expect(first).type.not.toBeCallableWith<[a?: "one"]>();

        at ./__typetests__/default-parameters.tst.ts:116:28 ❭ when target is a type ❭ expression can be called with provided argument

Error: Expression can be called with provided argument.

  117 | 
  118 |     expect(first).type.toBeCallableWith<[a?: "one"]>();
> 119 |     expect(first).type.not.toBeCallableWith<[a?: "one"]>();
      |                            ^
  120 | 
  121 |     expect(first).type.toBeCallableWith<[a: "one"]>();
  122 |     expect(first).type.not.toBeCallableWith<[a: "one"]>();

        at ./__typetests__/default-parameters.tst.ts:119:28 ❭ when target is a type ❭ expression can be called with provided argument

Error: Expression can be called with provided argument.

  120 | 
  121 |     expect(first).type.toBeCallableWith<[a: "one"]>();
> 122 |     expect(first).type.not.toBeCallableWith<[a: "one"]>();
      |                            ^
  123 | 
  124 |     expect(second).type.toBeCallableWith<["one"]>();
  125 |     expect(second).type.not.toBeCallableWith<["one"]>();

        at ./__typetests__/default-parameters.tst.ts:122:28 ❭ when target is a type ❭ expression can be called with provided argument

Error: Expression can be called with provided argument.

  123 | 
  124 |     expect(second).type.toBeCallableWith<["one"]>();
> 125 |     expect(second).type.not.toBeCallableWith<["one"]>();
      |                             ^
  126 | 
  127 |     expect(second).type.toBeCallableWith<[a: "one"]>();
  128 |     expect(second).type.not.toBeCallableWith<[a: "one"]>();

        at ./__typetests__/default-parameters.tst.ts:125:29 ❭ when target is a type ❭ expression can be called with provided argument

Error: Expression can be called with provided argument.

  126 | 
  127 |     expect(second).type.toBeCallableWith<[a: "one"]>();
> 128 |     expect(second).type.not.toBeCallableWith<[a: "one"]>();
      |                             ^
  129 |   });
  130 | 
  131 |   test("expression can be called with provided arguments", () => {

        at ./__typetests__/default-parameters.tst.ts:128:29 ❭ when target is a type ❭ expression can be called with provided argument

Error: Expression can be called with provided arguments.

  131 |   test("expression can be called with provided arguments", () => {
  132 |     expect(second).type.toBeCallableWith<["one", undefined]>();
> 133 |     expect(second).type.not.toBeCallableWith<["one", undefined]>();
      |                             ^
  134 | 
  135 |     expect(second).type.toBeCallableWith<["one", 123]>();
  136 |     expect(second).type.not.toBeCallableWith<["one", 123]>();

        at ./__typetests__/default-parameters.tst.ts:133:29 ❭ when target is a type ❭ expression can be called with provided arguments

Error: Expression can be called with provided arguments.

  134 | 
  135 |     expect(second).type.toBeCallableWith<["one", 123]>();
> 136 |     expect(second).type.not.toBeCallableWith<["one", 123]>();
      |                             ^
  137 | 
  138 |     expect(second).type.toBeCallableWith<[a: "one", b: undefined]>();
  139 |     expect(second).type.not.toBeCallableWith<[a: "one", b: undefined]>();

        at ./__typetests__/default-parameters.tst.ts:136:29 ❭ when target is a type ❭ expression can be called with provided arguments

Error: Expression can be called with provided arguments.

  137 | 
  138 |     expect(second).type.toBeCallableWith<[a: "one", b: undefined]>();
> 139 |     expect(second).type.not.toBeCallableWith<[a: "one", b: undefined]>();
      |                             ^
  140 | 
  141 |     expect(second).type.toBeCallableWith<[a: "one", b?: 123]>();
  142 |     expect(second).type.not.toBeCallableWith<[a: "one", b?: 123]>();

        at ./__typetests__/default-parameters.tst.ts:139:29 ❭ when target is a type ❭ expression can be called with provided arguments

Error: Expression can be called with provided arguments.

  140 | 
  141 |     expect(second).type.toBeCallableWith<[a: "one", b?: 123]>();
> 142 |     expect(second).type.not.toBeCallableWith<[a: "one", b?: 123]>();
      |                             ^
  143 | 
  144 |     expect(second).type.toBeCallableWith<[a: "one", b: 123]>();
  145 |     expect(second).type.not.toBeCallableWith<[a: "one", b: 123]>();

        at ./__typetests__/default-parameters.tst.ts:142:29 ❭ when target is a type ❭ expression can be called with provided arguments

Error: Expression can be called with provided arguments.

  143 | 
  144 |     expect(second).type.toBeCallableWith<[a: "one", b: 123]>();
> 145 |     expect(second).type.not.toBeCallableWith<[a: "one", b: 123]>();
      |                             ^
  146 |   });
  147 | 
  148 |   test("expression takes at most 1 argument", () => {

        at ./__typetests__/default-parameters.tst.ts:145:29 ❭ when target is a type ❭ expression can be called with provided arguments

Error: Expression takes at most 1 argument.

  148 |   test("expression takes at most 1 argument", () => {
  149 |     expect(first).type.not.toBeCallableWith<["one", undefined]>();
> 150 |     expect(first).type.toBeCallableWith<["one", undefined]>();
      |                        ^
  151 | 
  152 |     expect(first).type.not.toBeCallableWith<["one", "two"]>();
  153 |     expect(first).type.toBeCallableWith<["one", "two"]>();

        at ./__typetests__/default-parameters.tst.ts:150:24 ❭ when target is a type ❭ expression takes at most 1 argument

Error: Expression takes at most 1 argument.

  151 | 
  152 |     expect(first).type.not.toBeCallableWith<["one", "two"]>();
> 153 |     expect(first).type.toBeCallableWith<["one", "two"]>();
      |                        ^
  154 | 
  155 |     expect(first).type.not.toBeCallableWith<[a: "one", b: "two"]>();
  156 |     expect(first).type.toBeCallableWith<[a: "one", b: "two"]>();

        at ./__typetests__/default-parameters.tst.ts:153:24 ❭ when target is a type ❭ expression takes at most 1 argument

Error: Expression takes at most 1 argument.

  154 | 
  155 |     expect(first).type.not.toBeCallableWith<[a: "one", b: "two"]>();
> 156 |     expect(first).type.toBeCallableWith<[a: "one", b: "two"]>();
      |                        ^
  157 | 
  158 |     expect(first).type.not.toBeCallableWith<[a: "one", b: undefined]>();
  159 |     expect(first).type.toBeCallableWith<[a: "one", b: undefined]>();

        at ./__typetests__/default-parameters.tst.ts:156:24 ❭ when target is a type ❭ expression takes at most 1 argument

Error: Expression takes at most 1 argument.

  157 | 
  158 |     expect(first).type.not.toBeCallableWith<[a: "one", b: undefined]>();
> 159 |     expect(first).type.toBeCallableWith<[a: "one", b: undefined]>();
      |                        ^
  160 | 
  161 |     expect(first).type.not.toBeCallableWith<[a: "one", b?: "two"]>();
  162 |     expect(first).type.toBeCallableWith<[a: "one", b?: "two"]>();

        at ./__typetests__/default-parameters.tst.ts:159:24 ❭ when target is a type ❭ expression takes at most 1 argument

Error: Expression takes at most 1 argument.

  160 | 
  161 |     expect(first).type.not.toBeCallableWith<[a: "one", b?: "two"]>();
> 162 |     expect(first).type.toBeCallableWith<[a: "one", b?: "two"]>();
      |                        ^
  163 |   });
  164 | 
  165 |   test("expression takes at most 2 arguments", () => {

        at ./__typetests__/default-parameters.tst.ts:162:24 ❭ when target is a type ❭ expression takes at most 1 argument

Error: Expression takes at most 2 arguments.

  165 |   test("expression takes at most 2 arguments", () => {
  166 |     expect(second).type.not.toBeCallableWith<["one", 123, true]>();
> 167 |     expect(second).type.toBeCallableWith<["one", 123, true]>();
      |                         ^
  168 | 
  169 |     expect(second).type.not.toBeCallableWith<[a: "one", b: 123, c: true]>();
  170 |     expect(second).type.toBeCallableWith<[a: "one", b: 123, c: true]>();

        at ./__typetests__/default-parameters.tst.ts:167:25 ❭ when target is a type ❭ expression takes at most 2 arguments

Error: Expression takes at most 2 arguments.

  168 | 
  169 |     expect(second).type.not.toBeCallableWith<[a: "one", b: 123, c: true]>();
> 170 |     expect(second).type.toBeCallableWith<[a: "one", b: 123, c: true]>();
      |                         ^
  171 | 
  172 |     expect(second).type.not.toBeCallableWith<[a: "one", b: 123, c: undefined]>();
  173 |     expect(second).type.toBeCallableWith<[a: "one", b: 123, c: undefined]>();

        at ./__typetests__/default-parameters.tst.ts:170:25 ❭ when target is a type ❭ expression takes at most 2 arguments

Error: Expression takes at most 2 arguments.

  171 | 
  172 |     expect(second).type.not.toBeCallableWith<[a: "one", b: 123, c: undefined]>();
> 173 |     expect(second).type.toBeCallableWith<[a: "one", b: 123, c: undefined]>();
      |                         ^
  174 | 
  175 |     expect(second).type.not.toBeCallableWith<[a: "one", b: 123, c?: true]>();
  176 |     expect(second).type.toBeCallableWith<[a: "one", b: 123, c?: true]>();

        at ./__typetests__/default-parameters.tst.ts:173:25 ❭ when target is a type ❭ expression takes at most 2 arguments

Error: Expression takes at most 2 arguments.

  174 | 
  175 |     expect(second).type.not.toBeCallableWith<[a: "one", b: 123, c?: true]>();
> 176 |     expect(second).type.toBeCallableWith<[a: "one", b: 123, c?: true]>();
      |                         ^
  177 | 
  178 |     expect(second).type.not.toBeCallableWith<[a: "one", b: undefined, c: undefined]>();
  179 |     expect(second).type.toBeCallableWith<[a: "one", b: undefined, c: undefined]>();

        at ./__typetests__/default-parameters.tst.ts:176:25 ❭ when target is a type ❭ expression takes at most 2 arguments

Error: Expression takes at most 2 arguments.

  177 | 
  178 |     expect(second).type.not.toBeCallableWith<[a: "one", b: undefined, c: undefined]>();
> 179 |     expect(second).type.toBeCallableWith<[a: "one", b: undefined, c: undefined]>();
      |                         ^
  180 | 
  181 |     expect(second).type.not.toBeCallableWith<[a: "one", b?: 123, c?: true]>();
  182 |     expect(second).type.toBeCallableWith<[a: "one", b?: 123, c?: true]>();

        at ./__typetests__/default-parameters.tst.ts:179:25 ❭ when target is a type ❭ expression takes at most 2 arguments

Error: Expression takes at most 2 arguments.

  180 | 
  181 |     expect(second).type.not.toBeCallableWith<[a: "one", b?: 123, c?: true]>();
> 182 |     expect(second).type.toBeCallableWith<[a: "one", b?: 123, c?: true]>();
      |                         ^
  183 | 
  184 |     expect(second).type.not.toBeCallableWith<[a: undefined, b: undefined, c: undefined]>();
  185 |     expect(second).type.toBeCallableWith<[a: undefined, b: undefined, c: undefined]>();

        at ./__typetests__/default-parameters.tst.ts:182:25 ❭ when target is a type ❭ expression takes at most 2 arguments

Error: Expression takes at most 2 arguments.

  183 | 
  184 |     expect(second).type.not.toBeCallableWith<[a: undefined, b: undefined, c: undefined]>();
> 185 |     expect(second).type.toBeCallableWith<[a: undefined, b: undefined, c: undefined]>();
      |                         ^
  186 | 
  187 |     expect(second).type.not.toBeCallableWith<[a?: "one", b?: 123, c?: true]>();
  188 |     expect(second).type.toBeCallableWith<[a?: "one", b?: 123, c?: true]>();

        at ./__typetests__/default-parameters.tst.ts:185:25 ❭ when target is a type ❭ expression takes at most 2 arguments

Error: Expression takes at most 2 arguments.

  186 | 
  187 |     expect(second).type.not.toBeCallableWith<[a?: "one", b?: 123, c?: true]>();
> 188 |     expect(second).type.toBeCallableWith<[a?: "one", b?: 123, c?: true]>();
      |                         ^
  189 |   });
  190 | 
  191 |   test("type expression can be called without arguments", () => {

        at ./__typetests__/default-parameters.tst.ts:188:25 ❭ when target is a type ❭ expression takes at most 2 arguments

Error: Type expression can be called without arguments.

  191 |   test("type expression can be called without arguments", () => {
  192 |     expect<(a?: string) => void>().type.toBeCallableWith<[]>();
> 193 |     expect<(a?: string) => void>().type.not.toBeCallableWith<[]>();
      |                                             ^
  194 |   });
  195 | 
  196 |   test("type expression requires at least 1 argument", () => {

        at ./__typetests__/default-parameters.tst.ts:193:45 ❭ when target is a type ❭ type expression can be called without arguments

Error: Type expression requires at least 1 argument.

  196 |   test("type expression requires at least 1 argument", () => {
  197 |     expect<(a: string, b?: number) => void>().type.not.toBeCallableWith<[]>();
> 198 |     expect<(a: string, b?: number) => void>().type.toBeCallableWith<[]>();
      |                                                    ^
  199 | 
  200 |     expect<(a: string, b?: number) => void>().type.not.toBeCallableWith<[a?: "one"]>();
  201 |     expect<(a: string, b?: number) => void>().type.toBeCallableWith<[a?: "one"]>();

        at ./__typetests__/default-parameters.tst.ts:198:52 ❭ when target is a type ❭ type expression requires at least 1 argument

Error: Type expression requires at least 1 argument.

  199 | 
  200 |     expect<(a: string, b?: number) => void>().type.not.toBeCallableWith<[a?: "one"]>();
> 201 |     expect<(a: string, b?: number) => void>().type.toBeCallableWith<[a?: "one"]>();
      |                                                    ^
  202 | 
  203 |     expect<(a: string, b?: number) => void>().type.not.toBeCallableWith<[a?: "one", b?: 123]>();
  204 |     expect<(a: string, b?: number) => void>().type.toBeCallableWith<[a?: "one", b?: 123]>();

        at ./__typetests__/default-parameters.tst.ts:201:52 ❭ when target is a type ❭ type expression requires at least 1 argument

Error: Type expression requires at least 1 argument.

  202 | 
  203 |     expect<(a: string, b?: number) => void>().type.not.toBeCallableWith<[a?: "one", b?: 123]>();
> 204 |     expect<(a: string, b?: number) => void>().type.toBeCallableWith<[a?: "one", b?: 123]>();
      |                                                    ^
  205 |   });
  206 | 
  207 |   test("type expression can be called with provided argument", () => {

        at ./__typetests__/default-parameters.tst.ts:204:52 ❭ when target is a type ❭ type expression requires at least 1 argument

Error: Type expression can be called with provided argument.

  207 |   test("type expression can be called with provided argument", () => {
  208 |     expect<(a?: string) => void>().type.toBeCallableWith<[undefined]>();
> 209 |     expect<(a?: string) => void>().type.not.toBeCallableWith<[undefined]>();
      |                                             ^
  210 | 
  211 |     expect<(a?: string) => void>().type.toBeCallableWith<["one"]>();
  212 |     expect<(a?: string) => void>().type.not.toBeCallableWith<["one"]>();

        at ./__typetests__/default-parameters.tst.ts:209:45 ❭ when target is a type ❭ type expression can be called with provided argument

Error: Type expression can be called with provided argument.

  210 | 
  211 |     expect<(a?: string) => void>().type.toBeCallableWith<["one"]>();
> 212 |     expect<(a?: string) => void>().type.not.toBeCallableWith<["one"]>();
      |                                             ^
  213 | 
  214 |     expect<(a?: string) => void>().type.toBeCallableWith<[a: undefined]>();
  215 |     expect<(a?: string) => void>().type.not.toBeCallableWith<[a: undefined]>();

        at ./__typetests__/default-parameters.tst.ts:212:45 ❭ when target is a type ❭ type expression can be called with provided argument

Error: Type expression can be called with provided argument.

  213 | 
  214 |     expect<(a?: string) => void>().type.toBeCallableWith<[a: undefined]>();
> 215 |     expect<(a?: string) => void>().type.not.toBeCallableWith<[a: undefined]>();
      |                                             ^
  216 | 
  217 |     expect<(a?: string) => void>().type.toBeCallableWith<[a?: "one"]>();
  218 |     expect<(a?: string) => void>().type.not.toBeCallableWith<[a?: "one"]>();

        at ./__typetests__/default-parameters.tst.ts:215:45 ❭ when target is a type ❭ type expression can be called with provided argument

Error: Type expression can be called with provided argument.

  216 | 
  217 |     expect<(a?: string) => void>().type.toBeCallableWith<[a?: "one"]>();
> 218 |     expect<(a?: string) => void>().type.not.toBeCallableWith<[a?: "one"]>();
      |                                             ^
  219 | 
  220 |     expect<(a?: string) => void>().type.toBeCallableWith<[a: "one"]>();
  221 |     expect<(a?: string) => void>().type.not.toBeCallableWith<[a: "one"]>();

        at ./__typetests__/default-parameters.tst.ts:218:45 ❭ when target is a type ❭ type expression can be called with provided argument

Error: Type expression can be called with provided argument.

  219 | 
  220 |     expect<(a?: string) => void>().type.toBeCallableWith<[a: "one"]>();
> 221 |     expect<(a?: string) => void>().type.not.toBeCallableWith<[a: "one"]>();
      |                                             ^
  222 | 
  223 |     expect<(a: string, b?: number) => void>().type.toBeCallableWith<["one"]>();
  224 |     expect<(a: string, b?: number) => void>().type.not.toBeCallableWith<["one"]>();

        at ./__typetests__/default-parameters.tst.ts:221:45 ❭ when target is a type ❭ type expression can be called with provided argument

Error: Type expression can be called with provided argument.

  222 | 
  223 |     expect<(a: string, b?: number) => void>().type.toBeCallableWith<["one"]>();
> 224 |     expect<(a: string, b?: number) => void>().type.not.toBeCallableWith<["one"]>();
      |                                                        ^
  225 | 
  226 |     expect<(a: string, b?: number) => void>().type.toBeCallableWith<[a: "one"]>();
  227 |     expect<(a: string, b?: number) => void>().type.not.toBeCallableWith<[a: "one"]>();

        at ./__typetests__/default-parameters.tst.ts:224:56 ❭ when target is a type ❭ type expression can be called with provided argument

Error: Type expression can be called with provided argument.

  225 | 
  226 |     expect<(a: string, b?: number) => void>().type.toBeCallableWith<[a: "one"]>();
> 227 |     expect<(a: string, b?: number) => void>().type.not.toBeCallableWith<[a: "one"]>();
      |                                                        ^
  228 |   });
  229 | 
  230 |   test("type expression can be called with provided arguments", () => {

        at ./__typetests__/default-parameters.tst.ts:227:56 ❭ when target is a type ❭ type expression can be called with provided argument

Error: Type expression can be called with provided arguments.

  230 |   test("type expression can be called with provided arguments", () => {
  231 |     expect<(a: string, b?: number) => void>().type.toBeCallableWith<["one", undefined]>();
> 232 |     expect<(a: string, b?: number) => void>().type.not.toBeCallableWith<["one", undefined]>();
      |                                                        ^
  233 | 
  234 |     expect<(a: string, b?: number) => void>().type.toBeCallableWith<["one", 123]>();
  235 |     expect<(a: string, b?: number) => void>().type.not.toBeCallableWith<["one", 123]>();

        at ./__typetests__/default-parameters.tst.ts:232:56 ❭ when target is a type ❭ type expression can be called with provided arguments

Error: Type expression can be called with provided arguments.

  233 | 
  234 |     expect<(a: string, b?: number) => void>().type.toBeCallableWith<["one", 123]>();
> 235 |     expect<(a: string, b?: number) => void>().type.not.toBeCallableWith<["one", 123]>();
      |                                                        ^
  236 | 
  237 |     expect<(a: string, b?: number) => void>().type.toBeCallableWith<[a: "one", b: undefined]>();
  238 |     expect<(a: string, b?: number) => void>().type.not.toBeCallableWith<[a: "one", b: undefined]>();

        at ./__typetests__/default-parameters.tst.ts:235:56 ❭ when target is a type ❭ type expression can be called with provided arguments

Error: Type expression can be called with provided arguments.

  236 | 
  237 |     expect<(a: string, b?: number) => void>().type.toBeCallableWith<[a: "one", b: undefined]>();
> 238 |     expect<(a: string, b?: number) => void>().type.not.toBeCallableWith<[a: "one", b: undefined]>();
      |                                                        ^
  239 | 
  240 |     expect<(a: string, b?: number) => void>().type.toBeCallableWith<[a: "one", b?: 123]>();
  241 |     expect<(a: string, b?: number) => void>().type.not.toBeCallableWith<[a: "one", b?: 123]>();

        at ./__typetests__/default-parameters.tst.ts:238:56 ❭ when target is a type ❭ type expression can be called with provided arguments

Error: Type expression can be called with provided arguments.

  239 | 
  240 |     expect<(a: string, b?: number) => void>().type.toBeCallableWith<[a: "one", b?: 123]>();
> 241 |     expect<(a: string, b?: number) => void>().type.not.toBeCallableWith<[a: "one", b?: 123]>();
      |                                                        ^
  242 | 
  243 |     expect<(a: string, b?: number) => void>().type.toBeCallableWith<[a: "one", b: 123]>();
  244 |     expect<(a: string, b?: number) => void>().type.not.toBeCallableWith<[a: "one", b: 123]>();

        at ./__typetests__/default-parameters.tst.ts:241:56 ❭ when target is a type ❭ type expression can be called with provided arguments

Error: Type expression can be called with provided arguments.

  242 | 
  243 |     expect<(a: string, b?: number) => void>().type.toBeCallableWith<[a: "one", b: 123]>();
> 244 |     expect<(a: string, b?: number) => void>().type.not.toBeCallableWith<[a: "one", b: 123]>();
      |                                                        ^
  245 |   });
  246 | 
  247 |   test("type expression takes at most 1 argument", () => {

        at ./__typetests__/default-parameters.tst.ts:244:56 ❭ when target is a type ❭ type expression can be called with provided arguments

Error: Type expression takes at most 1 argument.

  247 |   test("type expression takes at most 1 argument", () => {
  248 |     expect<(a?: string) => void>().type.not.toBeCallableWith<["one", undefined]>();
> 249 |     expect<(a?: string) => void>().type.toBeCallableWith<["one", undefined]>();
      |                                         ^
  250 | 
  251 |     expect<(a?: string) => void>().type.not.toBeCallableWith<["one", "two"]>();
  252 |     expect<(a?: string) => void>().type.toBeCallableWith<["one", "two"]>();

        at ./__typetests__/default-parameters.tst.ts:249:41 ❭ when target is a type ❭ type expression takes at most 1 argument

Error: Type expression takes at most 1 argument.

  250 | 
  251 |     expect<(a?: string) => void>().type.not.toBeCallableWith<["one", "two"]>();
> 252 |     expect<(a?: string) => void>().type.toBeCallableWith<["one", "two"]>();
      |                                         ^
  253 | 
  254 |     expect<(a?: string) => void>().type.not.toBeCallableWith<[a: "one", b: "two"]>();
  255 |     expect<(a?: string) => void>().type.toBeCallableWith<[a: "one", b: "two"]>();

        at ./__typetests__/default-parameters.tst.ts:252:41 ❭ when target is a type ❭ type expression takes at most 1 argument

Error: Type expression takes at most 1 argument.

  253 | 
  254 |     expect<(a?: string) => void>().type.not.toBeCallableWith<[a: "one", b: "two"]>();
> 255 |     expect<(a?: string) => void>().type.toBeCallableWith<[a: "one", b: "two"]>();
      |                                         ^
  256 | 
  257 |     expect<(a?: string) => void>().type.not.toBeCallableWith<[a: "one", b: undefined]>();
  258 |     expect<(a?: string) => void>().type.toBeCallableWith<[a: "one", b: undefined]>();

        at ./__typetests__/default-parameters.tst.ts:255:41 ❭ when target is a type ❭ type expression takes at most 1 argument

Error: Type expression takes at most 1 argument.

  256 | 
  257 |     expect<(a?: string) => void>().type.not.toBeCallableWith<[a: "one", b: undefined]>();
> 258 |     expect<(a?: string) => void>().type.toBeCallableWith<[a: "one", b: undefined]>();
      |                                         ^
  259 | 
  260 |     expect<(a?: string) => void>().type.not.toBeCallableWith<[a: "one", b?: "two"]>();
  261 |     expect<(a?: string) => void>().type.toBeCallableWith<[a: "one", b?: "two"]>();

        at ./__typetests__/default-parameters.tst.ts:258:41 ❭ when target is a type ❭ type expression takes at most 1 argument

Error: Type expression takes at most 1 argument.

  259 | 
  260 |     expect<(a?: string) => void>().type.not.toBeCallableWith<[a: "one", b?: "two"]>();
> 261 |     expect<(a?: string) => void>().type.toBeCallableWith<[a: "one", b?: "two"]>();
      |                                         ^
  262 |   });
  263 | 
  264 |   test("type expression takes at most 2 arguments", () => {

        at ./__typetests__/default-parameters.tst.ts:261:41 ❭ when target is a type ❭ type expression takes at most 1 argument

Error: Type expression takes at most 2 arguments.

  264 |   test("type expression takes at most 2 arguments", () => {
  265 |     expect<(a: string, b?: number) => void>().type.not.toBeCallableWith<["one", 123, true]>();
> 266 |     expect<(a: string, b?: number) => void>().type.toBeCallableWith<["one", 123, true]>();
      |                                                    ^
  267 | 
  268 |     expect<(a: string, b?: number) => void>().type.not.toBeCallableWith<[a: "one", b: 123, c: true]>();
  269 |     expect<(a: string, b?: number) => void>().type.toBeCallableWith<[a: "one", b: 123, c: true]>();

        at ./__typetests__/default-parameters.tst.ts:266:52 ❭ when target is a type ❭ type expression takes at most 2 arguments

Error: Type expression takes at most 2 arguments.

  267 | 
  268 |     expect<(a: string, b?: number) => void>().type.not.toBeCallableWith<[a: "one", b: 123, c: true]>();
> 269 |     expect<(a: string, b?: number) => void>().type.toBeCallableWith<[a: "one", b: 123, c: true]>();
      |                                                    ^
  270 | 
  271 |     expect<(a: string, b?: number) => void>().type.not.toBeCallableWith<[a: "one", b: 123, c: undefined]>();
  272 |     expect<(a: string, b?: number) => void>().type.toBeCallableWith<[a: "one", b: 123, c: undefined]>();

        at ./__typetests__/default-parameters.tst.ts:269:52 ❭ when target is a type ❭ type expression takes at most 2 arguments

Error: Type expression takes at most 2 arguments.

  270 | 
  271 |     expect<(a: string, b?: number) => void>().type.not.toBeCallableWith<[a: "one", b: 123, c: undefined]>();
> 272 |     expect<(a: string, b?: number) => void>().type.toBeCallableWith<[a: "one", b: 123, c: undefined]>();
      |                                                    ^
  273 | 
  274 |     expect<(a: string, b?: number) => void>().type.not.toBeCallableWith<[a: "one", b: 123, c?: true]>();
  275 |     expect<(a: string, b?: number) => void>().type.toBeCallableWith<[a: "one", b: 123, c?: true]>();

        at ./__typetests__/default-parameters.tst.ts:272:52 ❭ when target is a type ❭ type expression takes at most 2 arguments

Error: Type expression takes at most 2 arguments.

  273 | 
  274 |     expect<(a: string, b?: number) => void>().type.not.toBeCallableWith<[a: "one", b: 123, c?: true]>();
> 275 |     expect<(a: string, b?: number) => void>().type.toBeCallableWith<[a: "one", b: 123, c?: true]>();
      |                                                    ^
  276 | 
  277 |     expect<(a: string, b?: number) => void>().type.not.toBeCallableWith<[a: "one", b: undefined, c: undefined]>();
  278 |     expect<(a: string, b?: number) => void>().type.toBeCallableWith<[a: "one", b: undefined, c: undefined]>();

        at ./__typetests__/default-parameters.tst.ts:275:52 ❭ when target is a type ❭ type expression takes at most 2 arguments

Error: Type expression takes at most 2 arguments.

  276 | 
  277 |     expect<(a: string, b?: number) => void>().type.not.toBeCallableWith<[a: "one", b: undefined, c: undefined]>();
> 278 |     expect<(a: string, b?: number) => void>().type.toBeCallableWith<[a: "one", b: undefined, c: undefined]>();
      |                                                    ^
  279 | 
  280 |     expect<(a: string, b?: number) => void>().type.not.toBeCallableWith<[a: "one", b?: 123, c?: true]>();
  281 |     expect<(a: string, b?: number) => void>().type.toBeCallableWith<[a: "one", b?: 123, c?: true]>();

        at ./__typetests__/default-parameters.tst.ts:278:52 ❭ when target is a type ❭ type expression takes at most 2 arguments

Error: Type expression takes at most 2 arguments.

  279 | 
  280 |     expect<(a: string, b?: number) => void>().type.not.toBeCallableWith<[a: "one", b?: 123, c?: true]>();
> 281 |     expect<(a: string, b?: number) => void>().type.toBeCallableWith<[a: "one", b?: 123, c?: true]>();
      |                                                    ^
  282 | 
  283 |     expect<(a: string, b?: number) => void>().type.not.toBeCallableWith<[a: undefined, b: undefined, c: undefined]>();
  284 |     expect<(a: string, b?: number) => void>().type.toBeCallableWith<[a: undefined, b: undefined, c: undefined]>();

        at ./__typetests__/default-parameters.tst.ts:281:52 ❭ when target is a type ❭ type expression takes at most 2 arguments

Error: Type expression takes at most 2 arguments.

  282 | 
  283 |     expect<(a: string, b?: number) => void>().type.not.toBeCallableWith<[a: undefined, b: undefined, c: undefined]>();
> 284 |     expect<(a: string, b?: number) => void>().type.toBeCallableWith<[a: undefined, b: undefined, c: undefined]>();
      |                                                    ^
  285 | 
  286 |     expect<(a: string, b?: number) => void>().type.not.toBeCallableWith<[a?: "one", b?: 123, c?: true]>();
  287 |     expect<(a: string, b?: number) => void>().type.toBeCallableWith<[a?: "one", b?: 123, c?: true]>();

        at ./__typetests__/default-parameters.tst.ts:284:52 ❭ when target is a type ❭ type expression takes at most 2 arguments

Error: Type expression takes at most 2 arguments.

  285 | 
  286 |     expect<(a: string, b?: number) => void>().type.not.toBeCallableWith<[a?: "one", b?: 123, c?: true]>();
> 287 |     expect<(a: string, b?: number) => void>().type.toBeCallableWith<[a?: "one", b?: 123, c?: true]>();
      |                                                    ^
  288 |   });
  289 | });
  290 | 

        at ./__typetests__/default-parameters.tst.ts:287:52 ❭ when target is a type ❭ type expression takes at most 2 arguments

"
`;

exports[`toBeCallableWith default parameters: stdout 1`] = `
"uses TypeScript <<version>> with ./tsconfig.json

fail ./__typetests__/default-parameters.tst.ts
  when target is a value
    × expression can be called without arguments
    × expression requires at least 1 argument
    × expression can be called with provided argument
    × expression can be called with provided arguments
    × expression takes at most 1 argument
    × expression takes at most 2 arguments
    × type expression can be called without arguments
    × type expression requires at least 1 argument
    × type expression can be called with provided argument
    × expression can be called with provided arguments
    × type expression takes at most 1 argument
    × expression takes at most 2 arguments
  when target is a type
    × expression can be called without arguments
    × expression requires at least 1 argument
    × expression can be called with provided argument
    × expression can be called with provided arguments
    × expression takes at most 1 argument
    × expression takes at most 2 arguments
    × type expression can be called without arguments
    × type expression requires at least 1 argument
    × type expression can be called with provided argument
    × type expression can be called with provided arguments
    × type expression takes at most 1 argument
    × type expression takes at most 2 arguments

Targets:    1 failed, 1 total
Test files: 1 failed, 1 total
Tests:      24 failed, 24 total
Assertions: 76 failed, 76 passed, 152 total
Duration:   <<timestamp>>

Ran test files matching 'default-parameters'.
"
`;

exports[`toBeCallableWith optional parameters: stderr 1`] = `
"Error: Expression can be called without arguments.

   7 |   test("expression can be called without arguments", () => {
   8 |     expect(first).type.toBeCallableWith();
>  9 |     expect(first).type.not.toBeCallableWith();
     |                            ^
  10 |   });
  11 | 
  12 |   test("expression requires at least 1 argument", () => {

       at ./__typetests__/optional-parameters.tst.ts:9:28 ❭ when target is a value ❭ expression can be called without arguments

Error: Expression requires at least 1 argument.

  12 |   test("expression requires at least 1 argument", () => {
  13 |     expect(second).type.not.toBeCallableWith();
> 14 |     expect(second).type.toBeCallableWith();
     |                         ^
  15 |   });
  16 | 
  17 |   test("expression can be called with provided argument", () => {

       at ./__typetests__/optional-parameters.tst.ts:14:25 ❭ when target is a value ❭ expression requires at least 1 argument

Error: Expression can be called with provided argument.

  17 |   test("expression can be called with provided argument", () => {
  18 |     expect(first).type.toBeCallableWith(undefined);
> 19 |     expect(first).type.not.toBeCallableWith(undefined);
     |                            ^
  20 | 
  21 |     expect(first).type.toBeCallableWith("one");
  22 |     expect(first).type.not.toBeCallableWith("one");

       at ./__typetests__/optional-parameters.tst.ts:19:28 ❭ when target is a value ❭ expression can be called with provided argument

Error: Expression can be called with provided argument.

  20 | 
  21 |     expect(first).type.toBeCallableWith("one");
> 22 |     expect(first).type.not.toBeCallableWith("one");
     |                            ^
  23 | 
  24 |     expect(second).type.toBeCallableWith("one");
  25 |     expect(second).type.not.toBeCallableWith("one");

       at ./__typetests__/optional-parameters.tst.ts:22:28 ❭ when target is a value ❭ expression can be called with provided argument

Error: Expression can be called with provided argument.

  23 | 
  24 |     expect(second).type.toBeCallableWith("one");
> 25 |     expect(second).type.not.toBeCallableWith("one");
     |                             ^
  26 |   });
  27 | 
  28 |   test("expression can be called with provided arguments", () => {

       at ./__typetests__/optional-parameters.tst.ts:25:29 ❭ when target is a value ❭ expression can be called with provided argument

Error: Expression can be called with provided arguments.

  28 |   test("expression can be called with provided arguments", () => {
  29 |     expect(second).type.toBeCallableWith("one", undefined);
> 30 |     expect(second).type.not.toBeCallableWith("one", undefined);
     |                             ^
  31 | 
  32 |     expect(second).type.toBeCallableWith("one", 123);
  33 |     expect(second).type.not.toBeCallableWith("one", 123);

       at ./__typetests__/optional-parameters.tst.ts:30:29 ❭ when target is a value ❭ expression can be called with provided arguments

Error: Expression can be called with provided arguments.

  31 | 
  32 |     expect(second).type.toBeCallableWith("one", 123);
> 33 |     expect(second).type.not.toBeCallableWith("one", 123);
     |                             ^
  34 |   });
  35 | 
  36 |   test("expression takes at most 1 argument", () => {

       at ./__typetests__/optional-parameters.tst.ts:33:29 ❭ when target is a value ❭ expression can be called with provided arguments

Error: Expression takes at most 1 argument.

  36 |   test("expression takes at most 1 argument", () => {
  37 |     expect(first).type.not.toBeCallableWith("one", "two");
> 38 |     expect(first).type.toBeCallableWith("one", "two");
     |                        ^
  39 |   });
  40 | 
  41 |   test("expression takes at most 2 arguments", () => {

       at ./__typetests__/optional-parameters.tst.ts:38:24 ❭ when target is a value ❭ expression takes at most 1 argument

Error: Expression takes at most 2 arguments.

  41 |   test("expression takes at most 2 arguments", () => {
  42 |     expect(second).type.not.toBeCallableWith("one", 123, true);
> 43 |     expect(second).type.toBeCallableWith("one", 123, true);
     |                         ^
  44 |   });
  45 | 
  46 |   test("type expression can be called without arguments", () => {

       at ./__typetests__/optional-parameters.tst.ts:43:25 ❭ when target is a value ❭ expression takes at most 2 arguments

Error: Type expression can be called without arguments.

  46 |   test("type expression can be called without arguments", () => {
  47 |     expect<(a?: string) => void>().type.toBeCallableWith();
> 48 |     expect<(a?: string) => void>().type.not.toBeCallableWith();
     |                                             ^
  49 |   });
  50 | 
  51 |   test("type expression requires at least 1 argument", () => {

       at ./__typetests__/optional-parameters.tst.ts:48:45 ❭ when target is a value ❭ type expression can be called without arguments

Error: Type expression requires at least 1 argument.

  51 |   test("type expression requires at least 1 argument", () => {
  52 |     expect<(a: string, b?: number) => void>().type.not.toBeCallableWith();
> 53 |     expect<(a: string, b?: number) => void>().type.toBeCallableWith();
     |                                                    ^
  54 |   });
  55 | 
  56 |   test("type expression can be called with provided argument", () => {

       at ./__typetests__/optional-parameters.tst.ts:53:52 ❭ when target is a value ❭ type expression requires at least 1 argument

Error: Type expression can be called with provided argument.

  56 |   test("type expression can be called with provided argument", () => {
  57 |     expect<(a?: string) => void>().type.toBeCallableWith(undefined);
> 58 |     expect<(a?: string) => void>().type.not.toBeCallableWith(undefined);
     |                                             ^
  59 | 
  60 |     expect<(a?: string) => void>().type.toBeCallableWith("one");
  61 |     expect<(a?: string) => void>().type.not.toBeCallableWith("one");

       at ./__typetests__/optional-parameters.tst.ts:58:45 ❭ when target is a value ❭ type expression can be called with provided argument

Error: Type expression can be called with provided argument.

  59 | 
  60 |     expect<(a?: string) => void>().type.toBeCallableWith("one");
> 61 |     expect<(a?: string) => void>().type.not.toBeCallableWith("one");
     |                                             ^
  62 | 
  63 |     expect<(a: string, b?: number) => void>().type.toBeCallableWith("one");
  64 |     expect<(a: string, b?: number) => void>().type.not.toBeCallableWith("one");

       at ./__typetests__/optional-parameters.tst.ts:61:45 ❭ when target is a value ❭ type expression can be called with provided argument

Error: Type expression can be called with provided argument.

  62 | 
  63 |     expect<(a: string, b?: number) => void>().type.toBeCallableWith("one");
> 64 |     expect<(a: string, b?: number) => void>().type.not.toBeCallableWith("one");
     |                                                        ^
  65 |   });
  66 | 
  67 |   test("expression can be called with provided arguments", () => {

       at ./__typetests__/optional-parameters.tst.ts:64:56 ❭ when target is a value ❭ type expression can be called with provided argument

Error: Type expression can be called with provided arguments.

  67 |   test("expression can be called with provided arguments", () => {
  68 |     expect<(a: string, b?: number) => void>().type.toBeCallableWith("one", undefined);
> 69 |     expect<(a: string, b?: number) => void>().type.not.toBeCallableWith("one", undefined);
     |                                                        ^
  70 | 
  71 |     expect<(a: string, b?: number) => void>().type.toBeCallableWith("one", 123);
  72 |     expect<(a: string, b?: number) => void>().type.not.toBeCallableWith("one", 123);

       at ./__typetests__/optional-parameters.tst.ts:69:56 ❭ when target is a value ❭ expression can be called with provided arguments

Error: Type expression can be called with provided arguments.

  70 | 
  71 |     expect<(a: string, b?: number) => void>().type.toBeCallableWith("one", 123);
> 72 |     expect<(a: string, b?: number) => void>().type.not.toBeCallableWith("one", 123);
     |                                                        ^
  73 |   });
  74 | 
  75 |   test("type expression takes at most 1 argument", () => {

       at ./__typetests__/optional-parameters.tst.ts:72:56 ❭ when target is a value ❭ expression can be called with provided arguments

Error: Type expression takes at most 1 argument.

  75 |   test("type expression takes at most 1 argument", () => {
  76 |     expect<(a?: string) => void>().type.not.toBeCallableWith("one", "two");
> 77 |     expect<(a?: string) => void>().type.toBeCallableWith("one", "two");
     |                                         ^
  78 |   });
  79 | 
  80 |   test("expression takes at most 2 arguments", () => {

       at ./__typetests__/optional-parameters.tst.ts:77:41 ❭ when target is a value ❭ type expression takes at most 1 argument

Error: Type expression takes at most 2 arguments.

  80 |   test("expression takes at most 2 arguments", () => {
  81 |     expect<(a: string, b?: number) => void>().type.not.toBeCallableWith("one", 123, true);
> 82 |     expect<(a: string, b?: number) => void>().type.toBeCallableWith("one", 123, true);
     |                                                    ^
  83 |   });
  84 | });
  85 | 

       at ./__typetests__/optional-parameters.tst.ts:82:52 ❭ when target is a value ❭ expression takes at most 2 arguments

Error: Expression can be called without arguments.

  87 |   test("expression can be called without arguments", () => {
  88 |     expect(first).type.toBeCallableWith<[]>();
> 89 |     expect(first).type.not.toBeCallableWith<[]>();
     |                            ^
  90 |   });
  91 | 
  92 |   test("expression requires at least 1 argument", () => {

       at ./__typetests__/optional-parameters.tst.ts:89:28 ❭ when target is a type ❭ expression can be called without arguments

Error: Expression requires at least 1 argument.

  92 |   test("expression requires at least 1 argument", () => {
  93 |     expect(second).type.not.toBeCallableWith<[]>();
> 94 |     expect(second).type.toBeCallableWith<[]>();
     |                         ^
  95 | 
  96 |     expect(second).type.not.toBeCallableWith<[a?: "one"]>();
  97 |     expect(second).type.toBeCallableWith<[a?: "one"]>();

       at ./__typetests__/optional-parameters.tst.ts:94:25 ❭ when target is a type ❭ expression requires at least 1 argument

Error: Expression requires at least 1 argument.

   95 | 
   96 |     expect(second).type.not.toBeCallableWith<[a?: "one"]>();
>  97 |     expect(second).type.toBeCallableWith<[a?: "one"]>();
      |                         ^
   98 | 
   99 |     expect(second).type.not.toBeCallableWith<[a?: "one", b?: 123]>();
  100 |     expect(second).type.toBeCallableWith<[a?: "one", b?: 123]>();

        at ./__typetests__/optional-parameters.tst.ts:97:25 ❭ when target is a type ❭ expression requires at least 1 argument

Error: Expression requires at least 1 argument.

   98 | 
   99 |     expect(second).type.not.toBeCallableWith<[a?: "one", b?: 123]>();
> 100 |     expect(second).type.toBeCallableWith<[a?: "one", b?: 123]>();
      |                         ^
  101 |   });
  102 | 
  103 |   test("expression can be called with provided argument", () => {

        at ./__typetests__/optional-parameters.tst.ts:100:25 ❭ when target is a type ❭ expression requires at least 1 argument

Error: Expression can be called with provided argument.

  103 |   test("expression can be called with provided argument", () => {
  104 |     expect(first).type.toBeCallableWith<[undefined]>();
> 105 |     expect(first).type.not.toBeCallableWith<[undefined]>();
      |                            ^
  106 | 
  107 |     expect(first).type.toBeCallableWith<["one"]>();
  108 |     expect(first).type.not.toBeCallableWith<["one"]>();

        at ./__typetests__/optional-parameters.tst.ts:105:28 ❭ when target is a type ❭ expression can be called with provided argument

Error: Expression can be called with provided argument.

  106 | 
  107 |     expect(first).type.toBeCallableWith<["one"]>();
> 108 |     expect(first).type.not.toBeCallableWith<["one"]>();
      |                            ^
  109 | 
  110 |     expect(first).type.toBeCallableWith<[a: undefined]>();
  111 |     expect(first).type.not.toBeCallableWith<[a: undefined]>();

        at ./__typetests__/optional-parameters.tst.ts:108:28 ❭ when target is a type ❭ expression can be called with provided argument

Error: Expression can be called with provided argument.

  109 | 
  110 |     expect(first).type.toBeCallableWith<[a: undefined]>();
> 111 |     expect(first).type.not.toBeCallableWith<[a: undefined]>();
      |                            ^
  112 | 
  113 |     expect(first).type.toBeCallableWith<[a?: "one"]>();
  114 |     expect(first).type.not.toBeCallableWith<[a?: "one"]>();

        at ./__typetests__/optional-parameters.tst.ts:111:28 ❭ when target is a type ❭ expression can be called with provided argument

Error: Expression can be called with provided argument.

  112 | 
  113 |     expect(first).type.toBeCallableWith<[a?: "one"]>();
> 114 |     expect(first).type.not.toBeCallableWith<[a?: "one"]>();
      |                            ^
  115 | 
  116 |     expect(first).type.toBeCallableWith<[a: "one"]>();
  117 |     expect(first).type.not.toBeCallableWith<[a: "one"]>();

        at ./__typetests__/optional-parameters.tst.ts:114:28 ❭ when target is a type ❭ expression can be called with provided argument

Error: Expression can be called with provided argument.

  115 | 
  116 |     expect(first).type.toBeCallableWith<[a: "one"]>();
> 117 |     expect(first).type.not.toBeCallableWith<[a: "one"]>();
      |                            ^
  118 | 
  119 |     expect(second).type.toBeCallableWith<["one"]>();
  120 |     expect(second).type.not.toBeCallableWith<["one"]>();

        at ./__typetests__/optional-parameters.tst.ts:117:28 ❭ when target is a type ❭ expression can be called with provided argument

Error: Expression can be called with provided argument.

  118 | 
  119 |     expect(second).type.toBeCallableWith<["one"]>();
> 120 |     expect(second).type.not.toBeCallableWith<["one"]>();
      |                             ^
  121 | 
  122 |     expect(second).type.toBeCallableWith<[a: "one"]>();
  123 |     expect(second).type.not.toBeCallableWith<[a: "one"]>();

        at ./__typetests__/optional-parameters.tst.ts:120:29 ❭ when target is a type ❭ expression can be called with provided argument

Error: Expression can be called with provided argument.

  121 | 
  122 |     expect(second).type.toBeCallableWith<[a: "one"]>();
> 123 |     expect(second).type.not.toBeCallableWith<[a: "one"]>();
      |                             ^
  124 |   });
  125 | 
  126 |   test("expression can be called with provided arguments", () => {

        at ./__typetests__/optional-parameters.tst.ts:123:29 ❭ when target is a type ❭ expression can be called with provided argument

Error: Expression can be called with provided arguments.

  126 |   test("expression can be called with provided arguments", () => {
  127 |     expect(second).type.toBeCallableWith<["one", undefined]>();
> 128 |     expect(second).type.not.toBeCallableWith<["one", undefined]>();
      |                             ^
  129 | 
  130 |     expect(second).type.toBeCallableWith<["one", 123]>();
  131 |     expect(second).type.not.toBeCallableWith<["one", 123]>();

        at ./__typetests__/optional-parameters.tst.ts:128:29 ❭ when target is a type ❭ expression can be called with provided arguments

Error: Expression can be called with provided arguments.

  129 | 
  130 |     expect(second).type.toBeCallableWith<["one", 123]>();
> 131 |     expect(second).type.not.toBeCallableWith<["one", 123]>();
      |                             ^
  132 | 
  133 |     expect(second).type.toBeCallableWith<[a: "one", b: undefined]>();
  134 |     expect(second).type.not.toBeCallableWith<[a: "one", b: undefined]>();

        at ./__typetests__/optional-parameters.tst.ts:131:29 ❭ when target is a type ❭ expression can be called with provided arguments

Error: Expression can be called with provided arguments.

  132 | 
  133 |     expect(second).type.toBeCallableWith<[a: "one", b: undefined]>();
> 134 |     expect(second).type.not.toBeCallableWith<[a: "one", b: undefined]>();
      |                             ^
  135 | 
  136 |     expect(second).type.toBeCallableWith<[a: "one", b?: 123]>();
  137 |     expect(second).type.not.toBeCallableWith<[a: "one", b?: 123]>();

        at ./__typetests__/optional-parameters.tst.ts:134:29 ❭ when target is a type ❭ expression can be called with provided arguments

Error: Expression can be called with provided arguments.

  135 | 
  136 |     expect(second).type.toBeCallableWith<[a: "one", b?: 123]>();
> 137 |     expect(second).type.not.toBeCallableWith<[a: "one", b?: 123]>();
      |                             ^
  138 | 
  139 |     expect(second).type.toBeCallableWith<[a: "one", b: 123]>();
  140 |     expect(second).type.not.toBeCallableWith<[a: "one", b: 123]>();

        at ./__typetests__/optional-parameters.tst.ts:137:29 ❭ when target is a type ❭ expression can be called with provided arguments

Error: Expression can be called with provided arguments.

  138 | 
  139 |     expect(second).type.toBeCallableWith<[a: "one", b: 123]>();
> 140 |     expect(second).type.not.toBeCallableWith<[a: "one", b: 123]>();
      |                             ^
  141 |   });
  142 | 
  143 |   test("expression takes at most 1 argument", () => {

        at ./__typetests__/optional-parameters.tst.ts:140:29 ❭ when target is a type ❭ expression can be called with provided arguments

Error: Expression takes at most 1 argument.

  143 |   test("expression takes at most 1 argument", () => {
  144 |     expect(first).type.not.toBeCallableWith<["one", undefined]>();
> 145 |     expect(first).type.toBeCallableWith<["one", undefined]>();
      |                        ^
  146 | 
  147 |     expect(first).type.not.toBeCallableWith<["one", "two"]>();
  148 |     expect(first).type.toBeCallableWith<["one", "two"]>();

        at ./__typetests__/optional-parameters.tst.ts:145:24 ❭ when target is a type ❭ expression takes at most 1 argument

Error: Expression takes at most 1 argument.

  146 | 
  147 |     expect(first).type.not.toBeCallableWith<["one", "two"]>();
> 148 |     expect(first).type.toBeCallableWith<["one", "two"]>();
      |                        ^
  149 | 
  150 |     expect(first).type.not.toBeCallableWith<[a: "one", b: "two"]>();
  151 |     expect(first).type.toBeCallableWith<[a: "one", b: "two"]>();

        at ./__typetests__/optional-parameters.tst.ts:148:24 ❭ when target is a type ❭ expression takes at most 1 argument

Error: Expression takes at most 1 argument.

  149 | 
  150 |     expect(first).type.not.toBeCallableWith<[a: "one", b: "two"]>();
> 151 |     expect(first).type.toBeCallableWith<[a: "one", b: "two"]>();
      |                        ^
  152 | 
  153 |     expect(first).type.not.toBeCallableWith<[a: "one", b: undefined]>();
  154 |     expect(first).type.toBeCallableWith<[a: "one", b: undefined]>();

        at ./__typetests__/optional-parameters.tst.ts:151:24 ❭ when target is a type ❭ expression takes at most 1 argument

Error: Expression takes at most 1 argument.

  152 | 
  153 |     expect(first).type.not.toBeCallableWith<[a: "one", b: undefined]>();
> 154 |     expect(first).type.toBeCallableWith<[a: "one", b: undefined]>();
      |                        ^
  155 | 
  156 |     expect(first).type.not.toBeCallableWith<[a: "one", b?: "two"]>();
  157 |     expect(first).type.toBeCallableWith<[a: "one", b?: "two"]>();

        at ./__typetests__/optional-parameters.tst.ts:154:24 ❭ when target is a type ❭ expression takes at most 1 argument

Error: Expression takes at most 1 argument.

  155 | 
  156 |     expect(first).type.not.toBeCallableWith<[a: "one", b?: "two"]>();
> 157 |     expect(first).type.toBeCallableWith<[a: "one", b?: "two"]>();
      |                        ^
  158 |   });
  159 | 
  160 |   test("expression takes at most 2 arguments", () => {

        at ./__typetests__/optional-parameters.tst.ts:157:24 ❭ when target is a type ❭ expression takes at most 1 argument

Error: Expression takes at most 2 arguments.

  160 |   test("expression takes at most 2 arguments", () => {
  161 |     expect(second).type.not.toBeCallableWith<["one", 123, true]>();
> 162 |     expect(second).type.toBeCallableWith<["one", 123, true]>();
      |                         ^
  163 | 
  164 |     expect(second).type.not.toBeCallableWith<[a: "one", b: 123, c: true]>();
  165 |     expect(second).type.toBeCallableWith<[a: "one", b: 123, c: true]>();

        at ./__typetests__/optional-parameters.tst.ts:162:25 ❭ when target is a type ❭ expression takes at most 2 arguments

Error: Expression takes at most 2 arguments.

  163 | 
  164 |     expect(second).type.not.toBeCallableWith<[a: "one", b: 123, c: true]>();
> 165 |     expect(second).type.toBeCallableWith<[a: "one", b: 123, c: true]>();
      |                         ^
  166 | 
  167 |     expect(second).type.not.toBeCallableWith<[a: "one", b: 123, c: undefined]>();
  168 |     expect(second).type.toBeCallableWith<[a: "one", b: 123, c: undefined]>();

        at ./__typetests__/optional-parameters.tst.ts:165:25 ❭ when target is a type ❭ expression takes at most 2 arguments

Error: Expression takes at most 2 arguments.

  166 | 
  167 |     expect(second).type.not.toBeCallableWith<[a: "one", b: 123, c: undefined]>();
> 168 |     expect(second).type.toBeCallableWith<[a: "one", b: 123, c: undefined]>();
      |                         ^
  169 | 
  170 |     expect(second).type.not.toBeCallableWith<[a: "one", b: 123, c?: true]>();
  171 |     expect(second).type.toBeCallableWith<[a: "one", b: 123, c?: true]>();

        at ./__typetests__/optional-parameters.tst.ts:168:25 ❭ when target is a type ❭ expression takes at most 2 arguments

Error: Expression takes at most 2 arguments.

  169 | 
  170 |     expect(second).type.not.toBeCallableWith<[a: "one", b: 123, c?: true]>();
> 171 |     expect(second).type.toBeCallableWith<[a: "one", b: 123, c?: true]>();
      |                         ^
  172 | 
  173 |     expect(second).type.not.toBeCallableWith<[a: "one", b: undefined, c: undefined]>();
  174 |     expect(second).type.toBeCallableWith<[a: "one", b: undefined, c: undefined]>();

        at ./__typetests__/optional-parameters.tst.ts:171:25 ❭ when target is a type ❭ expression takes at most 2 arguments

Error: Expression takes at most 2 arguments.

  172 | 
  173 |     expect(second).type.not.toBeCallableWith<[a: "one", b: undefined, c: undefined]>();
> 174 |     expect(second).type.toBeCallableWith<[a: "one", b: undefined, c: undefined]>();
      |                         ^
  175 | 
  176 |     expect(second).type.not.toBeCallableWith<[a: "one", b?: 123, c?: true]>();
  177 |     expect(second).type.toBeCallableWith<[a: "one", b?: 123, c?: true]>();

        at ./__typetests__/optional-parameters.tst.ts:174:25 ❭ when target is a type ❭ expression takes at most 2 arguments

Error: Expression takes at most 2 arguments.

  175 | 
  176 |     expect(second).type.not.toBeCallableWith<[a: "one", b?: 123, c?: true]>();
> 177 |     expect(second).type.toBeCallableWith<[a: "one", b?: 123, c?: true]>();
      |                         ^
  178 | 
  179 |     expect(second).type.not.toBeCallableWith<[a: undefined, b: undefined, c: undefined]>();
  180 |     expect(second).type.toBeCallableWith<[a: undefined, b: undefined, c: undefined]>();

        at ./__typetests__/optional-parameters.tst.ts:177:25 ❭ when target is a type ❭ expression takes at most 2 arguments

Error: Expression takes at most 2 arguments.

  178 | 
  179 |     expect(second).type.not.toBeCallableWith<[a: undefined, b: undefined, c: undefined]>();
> 180 |     expect(second).type.toBeCallableWith<[a: undefined, b: undefined, c: undefined]>();
      |                         ^
  181 | 
  182 |     expect(second).type.not.toBeCallableWith<[a?: "one", b?: 123, c?: true]>();
  183 |     expect(second).type.toBeCallableWith<[a?: "one", b?: 123, c?: true]>();

        at ./__typetests__/optional-parameters.tst.ts:180:25 ❭ when target is a type ❭ expression takes at most 2 arguments

Error: Expression takes at most 2 arguments.

  181 | 
  182 |     expect(second).type.not.toBeCallableWith<[a?: "one", b?: 123, c?: true]>();
> 183 |     expect(second).type.toBeCallableWith<[a?: "one", b?: 123, c?: true]>();
      |                         ^
  184 |   });
  185 | 
  186 |   test("type expression can be called without arguments", () => {

        at ./__typetests__/optional-parameters.tst.ts:183:25 ❭ when target is a type ❭ expression takes at most 2 arguments

Error: Type expression can be called without arguments.

  186 |   test("type expression can be called without arguments", () => {
  187 |     expect<(a?: string) => void>().type.toBeCallableWith<[]>();
> 188 |     expect<(a?: string) => void>().type.not.toBeCallableWith<[]>();
      |                                             ^
  189 |   });
  190 | 
  191 |   test("type expression requires at least 1 argument", () => {

        at ./__typetests__/optional-parameters.tst.ts:188:45 ❭ when target is a type ❭ type expression can be called without arguments

Error: Type expression requires at least 1 argument.

  191 |   test("type expression requires at least 1 argument", () => {
  192 |     expect<(a: string, b?: number) => void>().type.not.toBeCallableWith<[]>();
> 193 |     expect<(a: string, b?: number) => void>().type.toBeCallableWith<[]>();
      |                                                    ^
  194 | 
  195 |     expect<(a: string, b?: number) => void>().type.not.toBeCallableWith<[a?: "one"]>();
  196 |     expect<(a: string, b?: number) => void>().type.toBeCallableWith<[a?: "one"]>();

        at ./__typetests__/optional-parameters.tst.ts:193:52 ❭ when target is a type ❭ type expression requires at least 1 argument

Error: Type expression requires at least 1 argument.

  194 | 
  195 |     expect<(a: string, b?: number) => void>().type.not.toBeCallableWith<[a?: "one"]>();
> 196 |     expect<(a: string, b?: number) => void>().type.toBeCallableWith<[a?: "one"]>();
      |                                                    ^
  197 | 
  198 |     expect<(a: string, b?: number) => void>().type.not.toBeCallableWith<[a?: "one", b?: 123]>();
  199 |     expect<(a: string, b?: number) => void>().type.toBeCallableWith<[a?: "one", b?: 123]>();

        at ./__typetests__/optional-parameters.tst.ts:196:52 ❭ when target is a type ❭ type expression requires at least 1 argument

Error: Type expression requires at least 1 argument.

  197 | 
  198 |     expect<(a: string, b?: number) => void>().type.not.toBeCallableWith<[a?: "one", b?: 123]>();
> 199 |     expect<(a: string, b?: number) => void>().type.toBeCallableWith<[a?: "one", b?: 123]>();
      |                                                    ^
  200 |   });
  201 | 
  202 |   test("type expression can be called with provided argument", () => {

        at ./__typetests__/optional-parameters.tst.ts:199:52 ❭ when target is a type ❭ type expression requires at least 1 argument

Error: Type expression can be called with provided argument.

  202 |   test("type expression can be called with provided argument", () => {
  203 |     expect<(a?: string) => void>().type.toBeCallableWith<[undefined]>();
> 204 |     expect<(a?: string) => void>().type.not.toBeCallableWith<[undefined]>();
      |                                             ^
  205 | 
  206 |     expect<(a?: string) => void>().type.toBeCallableWith<["one"]>();
  207 |     expect<(a?: string) => void>().type.not.toBeCallableWith<["one"]>();

        at ./__typetests__/optional-parameters.tst.ts:204:45 ❭ when target is a type ❭ type expression can be called with provided argument

Error: Type expression can be called with provided argument.

  205 | 
  206 |     expect<(a?: string) => void>().type.toBeCallableWith<["one"]>();
> 207 |     expect<(a?: string) => void>().type.not.toBeCallableWith<["one"]>();
      |                                             ^
  208 | 
  209 |     expect<(a?: string) => void>().type.toBeCallableWith<[a: undefined]>();
  210 |     expect<(a?: string) => void>().type.not.toBeCallableWith<[a: undefined]>();

        at ./__typetests__/optional-parameters.tst.ts:207:45 ❭ when target is a type ❭ type expression can be called with provided argument

Error: Type expression can be called with provided argument.

  208 | 
  209 |     expect<(a?: string) => void>().type.toBeCallableWith<[a: undefined]>();
> 210 |     expect<(a?: string) => void>().type.not.toBeCallableWith<[a: undefined]>();
      |                                             ^
  211 | 
  212 |     expect<(a?: string) => void>().type.toBeCallableWith<[a?: "one"]>();
  213 |     expect<(a?: string) => void>().type.not.toBeCallableWith<[a?: "one"]>();

        at ./__typetests__/optional-parameters.tst.ts:210:45 ❭ when target is a type ❭ type expression can be called with provided argument

Error: Type expression can be called with provided argument.

  211 | 
  212 |     expect<(a?: string) => void>().type.toBeCallableWith<[a?: "one"]>();
> 213 |     expect<(a?: string) => void>().type.not.toBeCallableWith<[a?: "one"]>();
      |                                             ^
  214 | 
  215 |     expect<(a?: string) => void>().type.toBeCallableWith<[a: "one"]>();
  216 |     expect<(a?: string) => void>().type.not.toBeCallableWith<[a: "one"]>();

        at ./__typetests__/optional-parameters.tst.ts:213:45 ❭ when target is a type ❭ type expression can be called with provided argument

Error: Type expression can be called with provided argument.

  214 | 
  215 |     expect<(a?: string) => void>().type.toBeCallableWith<[a: "one"]>();
> 216 |     expect<(a?: string) => void>().type.not.toBeCallableWith<[a: "one"]>();
      |                                             ^
  217 | 
  218 |     expect<(a: string, b?: number) => void>().type.toBeCallableWith<["one"]>();
  219 |     expect<(a: string, b?: number) => void>().type.not.toBeCallableWith<["one"]>();

        at ./__typetests__/optional-parameters.tst.ts:216:45 ❭ when target is a type ❭ type expression can be called with provided argument

Error: Type expression can be called with provided argument.

  217 | 
  218 |     expect<(a: string, b?: number) => void>().type.toBeCallableWith<["one"]>();
> 219 |     expect<(a: string, b?: number) => void>().type.not.toBeCallableWith<["one"]>();
      |                                                        ^
  220 | 
  221 |     expect<(a: string, b?: number) => void>().type.toBeCallableWith<[a: "one"]>();
  222 |     expect<(a: string, b?: number) => void>().type.not.toBeCallableWith<[a: "one"]>();

        at ./__typetests__/optional-parameters.tst.ts:219:56 ❭ when target is a type ❭ type expression can be called with provided argument

Error: Type expression can be called with provided argument.

  220 | 
  221 |     expect<(a: string, b?: number) => void>().type.toBeCallableWith<[a: "one"]>();
> 222 |     expect<(a: string, b?: number) => void>().type.not.toBeCallableWith<[a: "one"]>();
      |                                                        ^
  223 |   });
  224 | 
  225 |   test("type expression can be called with provided arguments", () => {

        at ./__typetests__/optional-parameters.tst.ts:222:56 ❭ when target is a type ❭ type expression can be called with provided argument

Error: Type expression can be called with provided arguments.

  225 |   test("type expression can be called with provided arguments", () => {
  226 |     expect<(a: string, b?: number) => void>().type.toBeCallableWith<["one", undefined]>();
> 227 |     expect<(a: string, b?: number) => void>().type.not.toBeCallableWith<["one", undefined]>();
      |                                                        ^
  228 | 
  229 |     expect<(a: string, b?: number) => void>().type.toBeCallableWith<["one", 123]>();
  230 |     expect<(a: string, b?: number) => void>().type.not.toBeCallableWith<["one", 123]>();

        at ./__typetests__/optional-parameters.tst.ts:227:56 ❭ when target is a type ❭ type expression can be called with provided arguments

Error: Type expression can be called with provided arguments.

  228 | 
  229 |     expect<(a: string, b?: number) => void>().type.toBeCallableWith<["one", 123]>();
> 230 |     expect<(a: string, b?: number) => void>().type.not.toBeCallableWith<["one", 123]>();
      |                                                        ^
  231 | 
  232 |     expect<(a: string, b?: number) => void>().type.toBeCallableWith<[a: "one", b: undefined]>();
  233 |     expect<(a: string, b?: number) => void>().type.not.toBeCallableWith<[a: "one", b: undefined]>();

        at ./__typetests__/optional-parameters.tst.ts:230:56 ❭ when target is a type ❭ type expression can be called with provided arguments

Error: Type expression can be called with provided arguments.

  231 | 
  232 |     expect<(a: string, b?: number) => void>().type.toBeCallableWith<[a: "one", b: undefined]>();
> 233 |     expect<(a: string, b?: number) => void>().type.not.toBeCallableWith<[a: "one", b: undefined]>();
      |                                                        ^
  234 | 
  235 |     expect<(a: string, b?: number) => void>().type.toBeCallableWith<[a: "one", b?: 123]>();
  236 |     expect<(a: string, b?: number) => void>().type.not.toBeCallableWith<[a: "one", b?: 123]>();

        at ./__typetests__/optional-parameters.tst.ts:233:56 ❭ when target is a type ❭ type expression can be called with provided arguments

Error: Type expression can be called with provided arguments.

  234 | 
  235 |     expect<(a: string, b?: number) => void>().type.toBeCallableWith<[a: "one", b?: 123]>();
> 236 |     expect<(a: string, b?: number) => void>().type.not.toBeCallableWith<[a: "one", b?: 123]>();
      |                                                        ^
  237 | 
  238 |     expect<(a: string, b?: number) => void>().type.toBeCallableWith<[a: "one", b: 123]>();
  239 |     expect<(a: string, b?: number) => void>().type.not.toBeCallableWith<[a: "one", b: 123]>();

        at ./__typetests__/optional-parameters.tst.ts:236:56 ❭ when target is a type ❭ type expression can be called with provided arguments

Error: Type expression can be called with provided arguments.

  237 | 
  238 |     expect<(a: string, b?: number) => void>().type.toBeCallableWith<[a: "one", b: 123]>();
> 239 |     expect<(a: string, b?: number) => void>().type.not.toBeCallableWith<[a: "one", b: 123]>();
      |                                                        ^
  240 |   });
  241 | 
  242 |   test("type expression takes at most 1 argument", () => {

        at ./__typetests__/optional-parameters.tst.ts:239:56 ❭ when target is a type ❭ type expression can be called with provided arguments

Error: Type expression takes at most 1 argument.

  242 |   test("type expression takes at most 1 argument", () => {
  243 |     expect<(a?: string) => void>().type.not.toBeCallableWith<["one", undefined]>();
> 244 |     expect<(a?: string) => void>().type.toBeCallableWith<["one", undefined]>();
      |                                         ^
  245 | 
  246 |     expect<(a?: string) => void>().type.not.toBeCallableWith<["one", "two"]>();
  247 |     expect<(a?: string) => void>().type.toBeCallableWith<["one", "two"]>();

        at ./__typetests__/optional-parameters.tst.ts:244:41 ❭ when target is a type ❭ type expression takes at most 1 argument

Error: Type expression takes at most 1 argument.

  245 | 
  246 |     expect<(a?: string) => void>().type.not.toBeCallableWith<["one", "two"]>();
> 247 |     expect<(a?: string) => void>().type.toBeCallableWith<["one", "two"]>();
      |                                         ^
  248 | 
  249 |     expect<(a?: string) => void>().type.not.toBeCallableWith<[a: "one", b: "two"]>();
  250 |     expect<(a?: string) => void>().type.toBeCallableWith<[a: "one", b: "two"]>();

        at ./__typetests__/optional-parameters.tst.ts:247:41 ❭ when target is a type ❭ type expression takes at most 1 argument

Error: Type expression takes at most 1 argument.

  248 | 
  249 |     expect<(a?: string) => void>().type.not.toBeCallableWith<[a: "one", b: "two"]>();
> 250 |     expect<(a?: string) => void>().type.toBeCallableWith<[a: "one", b: "two"]>();
      |                                         ^
  251 | 
  252 |     expect<(a?: string) => void>().type.not.toBeCallableWith<[a: "one", b: undefined]>();
  253 |     expect<(a?: string) => void>().type.toBeCallableWith<[a: "one", b: undefined]>();

        at ./__typetests__/optional-parameters.tst.ts:250:41 ❭ when target is a type ❭ type expression takes at most 1 argument

Error: Type expression takes at most 1 argument.

  251 | 
  252 |     expect<(a?: string) => void>().type.not.toBeCallableWith<[a: "one", b: undefined]>();
> 253 |     expect<(a?: string) => void>().type.toBeCallableWith<[a: "one", b: undefined]>();
      |                                         ^
  254 | 
  255 |     expect<(a?: string) => void>().type.not.toBeCallableWith<[a: "one", b?: "two"]>();
  256 |     expect<(a?: string) => void>().type.toBeCallableWith<[a: "one", b?: "two"]>();

        at ./__typetests__/optional-parameters.tst.ts:253:41 ❭ when target is a type ❭ type expression takes at most 1 argument

Error: Type expression takes at most 1 argument.

  254 | 
  255 |     expect<(a?: string) => void>().type.not.toBeCallableWith<[a: "one", b?: "two"]>();
> 256 |     expect<(a?: string) => void>().type.toBeCallableWith<[a: "one", b?: "two"]>();
      |                                         ^
  257 |   });
  258 | 
  259 |   test("type expression takes at most 2 arguments", () => {

        at ./__typetests__/optional-parameters.tst.ts:256:41 ❭ when target is a type ❭ type expression takes at most 1 argument

Error: Type expression takes at most 2 arguments.

  259 |   test("type expression takes at most 2 arguments", () => {
  260 |     expect<(a: string, b?: number) => void>().type.not.toBeCallableWith<["one", 123, true]>();
> 261 |     expect<(a: string, b?: number) => void>().type.toBeCallableWith<["one", 123, true]>();
      |                                                    ^
  262 | 
  263 |     expect<(a: string, b?: number) => void>().type.not.toBeCallableWith<[a: "one", b: 123, c: true]>();
  264 |     expect<(a: string, b?: number) => void>().type.toBeCallableWith<[a: "one", b: 123, c: true]>();

        at ./__typetests__/optional-parameters.tst.ts:261:52 ❭ when target is a type ❭ type expression takes at most 2 arguments

Error: Type expression takes at most 2 arguments.

  262 | 
  263 |     expect<(a: string, b?: number) => void>().type.not.toBeCallableWith<[a: "one", b: 123, c: true]>();
> 264 |     expect<(a: string, b?: number) => void>().type.toBeCallableWith<[a: "one", b: 123, c: true]>();
      |                                                    ^
  265 | 
  266 |     expect<(a: string, b?: number) => void>().type.not.toBeCallableWith<[a: "one", b: 123, c: undefined]>();
  267 |     expect<(a: string, b?: number) => void>().type.toBeCallableWith<[a: "one", b: 123, c: undefined]>();

        at ./__typetests__/optional-parameters.tst.ts:264:52 ❭ when target is a type ❭ type expression takes at most 2 arguments

Error: Type expression takes at most 2 arguments.

  265 | 
  266 |     expect<(a: string, b?: number) => void>().type.not.toBeCallableWith<[a: "one", b: 123, c: undefined]>();
> 267 |     expect<(a: string, b?: number) => void>().type.toBeCallableWith<[a: "one", b: 123, c: undefined]>();
      |                                                    ^
  268 | 
  269 |     expect<(a: string, b?: number) => void>().type.not.toBeCallableWith<[a: "one", b: 123, c?: true]>();
  270 |     expect<(a: string, b?: number) => void>().type.toBeCallableWith<[a: "one", b: 123, c?: true]>();

        at ./__typetests__/optional-parameters.tst.ts:267:52 ❭ when target is a type ❭ type expression takes at most 2 arguments

Error: Type expression takes at most 2 arguments.

  268 | 
  269 |     expect<(a: string, b?: number) => void>().type.not.toBeCallableWith<[a: "one", b: 123, c?: true]>();
> 270 |     expect<(a: string, b?: number) => void>().type.toBeCallableWith<[a: "one", b: 123, c?: true]>();
      |                                                    ^
  271 | 
  272 |     expect<(a: string, b?: number) => void>().type.not.toBeCallableWith<[a: "one", b: undefined, c: undefined]>();
  273 |     expect<(a: string, b?: number) => void>().type.toBeCallableWith<[a: "one", b: undefined, c: undefined]>();

        at ./__typetests__/optional-parameters.tst.ts:270:52 ❭ when target is a type ❭ type expression takes at most 2 arguments

Error: Type expression takes at most 2 arguments.

  271 | 
  272 |     expect<(a: string, b?: number) => void>().type.not.toBeCallableWith<[a: "one", b: undefined, c: undefined]>();
> 273 |     expect<(a: string, b?: number) => void>().type.toBeCallableWith<[a: "one", b: undefined, c: undefined]>();
      |                                                    ^
  274 | 
  275 |     expect<(a: string, b?: number) => void>().type.not.toBeCallableWith<[a: "one", b?: 123, c?: true]>();
  276 |     expect<(a: string, b?: number) => void>().type.toBeCallableWith<[a: "one", b?: 123, c?: true]>();

        at ./__typetests__/optional-parameters.tst.ts:273:52 ❭ when target is a type ❭ type expression takes at most 2 arguments

Error: Type expression takes at most 2 arguments.

  274 | 
  275 |     expect<(a: string, b?: number) => void>().type.not.toBeCallableWith<[a: "one", b?: 123, c?: true]>();
> 276 |     expect<(a: string, b?: number) => void>().type.toBeCallableWith<[a: "one", b?: 123, c?: true]>();
      |                                                    ^
  277 | 
  278 |     expect<(a: string, b?: number) => void>().type.not.toBeCallableWith<[a: undefined, b: undefined, c: undefined]>();
  279 |     expect<(a: string, b?: number) => void>().type.toBeCallableWith<[a: undefined, b: undefined, c: undefined]>();

        at ./__typetests__/optional-parameters.tst.ts:276:52 ❭ when target is a type ❭ type expression takes at most 2 arguments

Error: Type expression takes at most 2 arguments.

  277 | 
  278 |     expect<(a: string, b?: number) => void>().type.not.toBeCallableWith<[a: undefined, b: undefined, c: undefined]>();
> 279 |     expect<(a: string, b?: number) => void>().type.toBeCallableWith<[a: undefined, b: undefined, c: undefined]>();
      |                                                    ^
  280 | 
  281 |     expect<(a: string, b?: number) => void>().type.not.toBeCallableWith<[a?: "one", b?: 123, c?: true]>();
  282 |     expect<(a: string, b?: number) => void>().type.toBeCallableWith<[a?: "one", b?: 123, c?: true]>();

        at ./__typetests__/optional-parameters.tst.ts:279:52 ❭ when target is a type ❭ type expression takes at most 2 arguments

Error: Type expression takes at most 2 arguments.

  280 | 
  281 |     expect<(a: string, b?: number) => void>().type.not.toBeCallableWith<[a?: "one", b?: 123, c?: true]>();
> 282 |     expect<(a: string, b?: number) => void>().type.toBeCallableWith<[a?: "one", b?: 123, c?: true]>();
      |                                                    ^
  283 |   });
  284 | });
  285 | 

        at ./__typetests__/optional-parameters.tst.ts:282:52 ❭ when target is a type ❭ type expression takes at most 2 arguments

"
`;

exports[`toBeCallableWith optional parameters: stdout 1`] = `
"uses TypeScript <<version>> with ./tsconfig.json

fail ./__typetests__/optional-parameters.tst.ts
  when target is a value
    × expression can be called without arguments
    × expression requires at least 1 argument
    × expression can be called with provided argument
    × expression can be called with provided arguments
    × expression takes at most 1 argument
    × expression takes at most 2 arguments
    × type expression can be called without arguments
    × type expression requires at least 1 argument
    × type expression can be called with provided argument
    × expression can be called with provided arguments
    × type expression takes at most 1 argument
    × expression takes at most 2 arguments
  when target is a type
    × expression can be called without arguments
    × expression requires at least 1 argument
    × expression can be called with provided argument
    × expression can be called with provided arguments
    × expression takes at most 1 argument
    × expression takes at most 2 arguments
    × type expression can be called without arguments
    × type expression requires at least 1 argument
    × type expression can be called with provided argument
    × type expression can be called with provided arguments
    × type expression takes at most 1 argument
    × type expression takes at most 2 arguments

Targets:    1 failed, 1 total
Test files: 1 failed, 1 total
Tests:      24 failed, 24 total
Assertions: 76 failed, 76 passed, 152 total
Duration:   <<timestamp>>

Ran test files matching 'optional-parameters'.
"
`;

exports[`toBeCallableWith parameter arity: stderr 1`] = `
"Error: Expression can be called without arguments.

   9 |   test("expression can be called without arguments", () => {
  10 |     expect(() => null).type.toBeCallableWith();
> 11 |     expect(() => null).type.not.toBeCallableWith();
     |                                 ^
  12 |   });
  13 | 
  14 |   test("expression does not take arguments", () => {

       at ./__typetests__/parameter-arity.test.ts:11:33 ❭ when target is a value ❭ expression can be called without arguments

Error: Expression does not take arguments.

  14 |   test("expression does not take arguments", () => {
  15 |     expect(() => null).type.not.toBeCallableWith("one");
> 16 |     expect(() => null).type.toBeCallableWith("one");
     |                             ^
  17 |   });
  18 | 
  19 |   test("expression can be called with provided argument", () => {

       at ./__typetests__/parameter-arity.test.ts:16:29 ❭ when target is a value ❭ expression does not take arguments

Error: Expression can be called with provided argument.

  19 |   test("expression can be called with provided argument", () => {
  20 |     expect((a: string) => a).type.toBeCallableWith("one");
> 21 |     expect((a: string) => a).type.not.toBeCallableWith("one");
     |                                       ^
  22 |   });
  23 | 
  24 |   test("expression requires 1 argument", () => {

       at ./__typetests__/parameter-arity.test.ts:21:39 ❭ when target is a value ❭ expression can be called with provided argument

Error: Expression requires 1 argument.

  24 |   test("expression requires 1 argument", () => {
  25 |     expect((a: string) => a).type.not.toBeCallableWith();
> 26 |     expect((a: string) => a).type.toBeCallableWith();
     |                                   ^
  27 |   });
  28 | 
  29 |   test("expression takes only 1 argument", () => {

       at ./__typetests__/parameter-arity.test.ts:26:35 ❭ when target is a value ❭ expression requires 1 argument

Error: Expression takes only 1 argument.

  29 |   test("expression takes only 1 argument", () => {
  30 |     expect((a: string) => a).type.not.toBeCallableWith("one", "two");
> 31 |     expect((a: string) => a).type.toBeCallableWith("one", "two");
     |                                   ^
  32 |   });
  33 | 
  34 |   test("type expression can be called without arguments", () => {

       at ./__typetests__/parameter-arity.test.ts:31:35 ❭ when target is a value ❭ expression takes only 1 argument

Error: Type expression can be called without arguments.

  34 |   test("type expression can be called without arguments", () => {
  35 |     expect<() => null>().type.toBeCallableWith();
> 36 |     expect<() => null>().type.not.toBeCallableWith();
     |                                   ^
  37 |   });
  38 | 
  39 |   test("type expression does not take arguments", () => {

       at ./__typetests__/parameter-arity.test.ts:36:35 ❭ when target is a value ❭ type expression can be called without arguments

Error: Type expression does not take arguments.

  39 |   test("type expression does not take arguments", () => {
  40 |     expect<() => null>().type.not.toBeCallableWith("one");
> 41 |     expect<() => null>().type.toBeCallableWith("one");
     |                               ^
  42 |   });
  43 | 
  44 |   test("type expression can be called with provided argument", () => {

       at ./__typetests__/parameter-arity.test.ts:41:31 ❭ when target is a value ❭ type expression does not take arguments

Error: Type expression can be called with provided argument.

  44 |   test("type expression can be called with provided argument", () => {
  45 |     expect<(a: string) => string>().type.toBeCallableWith("one");
> 46 |     expect<(a: string) => string>().type.not.toBeCallableWith("one");
     |                                              ^
  47 |   });
  48 | 
  49 |   test("type expression requires 1 argument", () => {

       at ./__typetests__/parameter-arity.test.ts:46:46 ❭ when target is a value ❭ type expression can be called with provided argument

Error: Type expression requires 1 argument.

  49 |   test("type expression requires 1 argument", () => {
  50 |     expect<(a: string) => string>().type.not.toBeCallableWith();
> 51 |     expect<(a: string) => string>().type.toBeCallableWith();
     |                                          ^
  52 |   });
  53 | 
  54 |   test("type expression takes only 1 argument", () => {

       at ./__typetests__/parameter-arity.test.ts:51:42 ❭ when target is a value ❭ type expression requires 1 argument

Error: Type expression takes only 1 argument.

  54 |   test("type expression takes only 1 argument", () => {
  55 |     expect<(a: string) => string>().type.not.toBeCallableWith("one", "two");
> 56 |     expect<(a: string) => string>().type.toBeCallableWith("one", "two");
     |                                          ^
  57 |   });
  58 | });
  59 | 

       at ./__typetests__/parameter-arity.test.ts:56:42 ❭ when target is a value ❭ type expression takes only 1 argument

Error: Expression can be called without arguments.

  61 |   test("expression can be called without arguments", () => {
  62 |     expect(() => null).type.toBeCallableWith<[]>();
> 63 |     expect(() => null).type.not.toBeCallableWith<[]>();
     |                                 ^
  64 |   });
  65 | 
  66 |   test("expression does not take arguments", () => {

       at ./__typetests__/parameter-arity.test.ts:63:33 ❭ when target is a type ❭ expression can be called without arguments

Error: Expression does not take arguments.

  66 |   test("expression does not take arguments", () => {
  67 |     expect(() => null).type.not.toBeCallableWith<["one"]>();
> 68 |     expect(() => null).type.toBeCallableWith<["one"]>();
     |                             ^
  69 |   });
  70 | 
  71 |   test("expression can be called with provided argument", () => {

       at ./__typetests__/parameter-arity.test.ts:68:29 ❭ when target is a type ❭ expression does not take arguments

Error: Expression can be called with provided argument.

  71 |   test("expression can be called with provided argument", () => {
  72 |     expect((a: string) => a).type.toBeCallableWith<["one"]>();
> 73 |     expect((a: string) => a).type.not.toBeCallableWith<["one"]>();
     |                                       ^
  74 |   });
  75 | 
  76 |   test("expression requires 1 argument", () => {

       at ./__typetests__/parameter-arity.test.ts:73:39 ❭ when target is a type ❭ expression can be called with provided argument

Error: Expression requires 1 argument.

  76 |   test("expression requires 1 argument", () => {
  77 |     expect((a: string) => a).type.not.toBeCallableWith<[]>();
> 78 |     expect((a: string) => a).type.toBeCallableWith<[]>();
     |                                   ^
  79 |   });
  80 | 
  81 |   test("expression takes only 1 argument", () => {

       at ./__typetests__/parameter-arity.test.ts:78:35 ❭ when target is a type ❭ expression requires 1 argument

Error: Expression takes only 1 argument.

  81 |   test("expression takes only 1 argument", () => {
  82 |     expect((a: string) => a).type.not.toBeCallableWith<["one", "two"]>();
> 83 |     expect((a: string) => a).type.toBeCallableWith<["one", "two"]>();
     |                                   ^
  84 |   });
  85 | 
  86 |   test("type expression can be called without arguments", () => {

       at ./__typetests__/parameter-arity.test.ts:83:35 ❭ when target is a type ❭ expression takes only 1 argument

Error: Type expression can be called without arguments.

  86 |   test("type expression can be called without arguments", () => {
  87 |     expect<() => null>().type.toBeCallableWith<[]>();
> 88 |     expect<() => null>().type.not.toBeCallableWith<[]>();
     |                                   ^
  89 |   });
  90 | 
  91 |   test("type expression does not take arguments", () => {

       at ./__typetests__/parameter-arity.test.ts:88:35 ❭ when target is a type ❭ type expression can be called without arguments

Error: Type expression does not take arguments.

  91 |   test("type expression does not take arguments", () => {
  92 |     expect<() => null>().type.not.toBeCallableWith<["one"]>();
> 93 |     expect<() => null>().type.toBeCallableWith<["one"]>();
     |                               ^
  94 |   });
  95 | 
  96 |   test("type expression can be called with provided argument", () => {

       at ./__typetests__/parameter-arity.test.ts:93:31 ❭ when target is a type ❭ type expression does not take arguments

Error: Type expression can be called with provided argument.

   96 |   test("type expression can be called with provided argument", () => {
   97 |     expect<(a: string) => string>().type.toBeCallableWith<["one"]>();
>  98 |     expect<(a: string) => string>().type.not.toBeCallableWith<["one"]>();
      |                                              ^
   99 |   });
  100 | 
  101 |   test("type expression requires 1 argument", () => {

        at ./__typetests__/parameter-arity.test.ts:98:46 ❭ when target is a type ❭ type expression can be called with provided argument

Error: Type expression requires 1 argument.

  101 |   test("type expression requires 1 argument", () => {
  102 |     expect<(a: string) => string>().type.not.toBeCallableWith<[]>();
> 103 |     expect<(a: string) => string>().type.toBeCallableWith<[]>();
      |                                          ^
  104 |   });
  105 | 
  106 |   test("type expression takes only 1 argument", () => {

        at ./__typetests__/parameter-arity.test.ts:103:42 ❭ when target is a type ❭ type expression requires 1 argument

Error: Type expression takes only 1 argument.

  106 |   test("type expression takes only 1 argument", () => {
  107 |     expect<(a: string) => string>().type.not.toBeCallableWith<["one", "two"]>();
> 108 |     expect<(a: string) => string>().type.toBeCallableWith<["one", "two"]>();
      |                                          ^
  109 |   });
  110 | });
  111 | 

        at ./__typetests__/parameter-arity.test.ts:108:42 ❭ when target is a type ❭ type expression takes only 1 argument

"
`;

exports[`toBeCallableWith parameter arity: stdout 1`] = `
"uses TypeScript <<version>> with ./tsconfig.json

fail ./__typetests__/parameter-arity.test.ts
  when target is a value
    × expression can be called without arguments
    × expression does not take arguments
    × expression can be called with provided argument
    × expression requires 1 argument
    × expression takes only 1 argument
    × type expression can be called without arguments
    × type expression does not take arguments
    × type expression can be called with provided argument
    × type expression requires 1 argument
    × type expression takes only 1 argument
  when target is a type
    × expression can be called without arguments
    × expression does not take arguments
    × expression can be called with provided argument
    × expression requires 1 argument
    × expression takes only 1 argument
    × type expression can be called without arguments
    × type expression does not take arguments
    × type expression can be called with provided argument
    × type expression requires 1 argument
    × type expression takes only 1 argument

Targets:    1 failed, 1 total
Test files: 1 failed, 1 total
Tests:      20 failed, 20 total
Assertions: 20 failed, 20 passed, 40 total
Duration:   <<timestamp>>

Ran test files matching 'parameter-arity'.
"
`;
