// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`toBeCallableWith: stderr 1`] = `
"Error: Expression can be called without arguments.

   9 |   test("expression can be called without arguments", () => {
  10 |     expect(() => null).type.toBeCallableWith();
> 11 |     expect(() => null).type.not.toBeCallableWith();
     |                                 ^
  12 |   });
  13 | 
  14 |   test("expression does not take arguments", () => {

       at ./__typetests__/toBeCallableWith.test.ts:11:33 ❭ when target is a value ❭ expression can be called without arguments

Error: Expression does not take arguments.

  14 |   test("expression does not take arguments", () => {
  15 |     expect(() => null).type.not.toBeCallableWith("one");
> 16 |     expect(() => null).type.toBeCallableWith("one");
     |                             ^
  17 |   });
  18 | 
  19 |   test("expression can be called with provided argument", () => {

       at ./__typetests__/toBeCallableWith.test.ts:16:29 ❭ when target is a value ❭ expression does not take arguments

Error: Expression can be called with provided argument.

  19 |   test("expression can be called with provided argument", () => {
  20 |     expect((a: string) => a).type.toBeCallableWith("one");
> 21 |     expect((a: string) => a).type.not.toBeCallableWith("one");
     |                                       ^
  22 |   });
  23 | 
  24 |   test("expression requires 1 argument", () => {

       at ./__typetests__/toBeCallableWith.test.ts:21:39 ❭ when target is a value ❭ expression can be called with provided argument

Error: Expression requires 1 argument.

  24 |   test("expression requires 1 argument", () => {
  25 |     expect((a: string) => a).type.not.toBeCallableWith();
> 26 |     expect((a: string) => a).type.toBeCallableWith();
     |                                   ^
  27 |   });
  28 | 
  29 |   test("expression takes only 1 argument", () => {

       at ./__typetests__/toBeCallableWith.test.ts:26:35 ❭ when target is a value ❭ expression requires 1 argument

Error: Expression takes only 1 argument.

  29 |   test("expression takes only 1 argument", () => {
  30 |     expect((a: string) => a).type.not.toBeCallableWith("one", "two");
> 31 |     expect((a: string) => a).type.toBeCallableWith("one", "two");
     |                                   ^
  32 |   });
  33 | 
  34 |   test("type expression can be called without arguments", () => {

       at ./__typetests__/toBeCallableWith.test.ts:31:35 ❭ when target is a value ❭ expression takes only 1 argument

Error: Type expression can be called without arguments.

  34 |   test("type expression can be called without arguments", () => {
  35 |     expect<() => null>().type.toBeCallableWith();
> 36 |     expect<() => null>().type.not.toBeCallableWith();
     |                                   ^
  37 |   });
  38 | 
  39 |   test("type expression does not take arguments", () => {

       at ./__typetests__/toBeCallableWith.test.ts:36:35 ❭ when target is a value ❭ type expression can be called without arguments

Error: Type expression does not take arguments.

  39 |   test("type expression does not take arguments", () => {
  40 |     expect<() => null>().type.not.toBeCallableWith("one");
> 41 |     expect<() => null>().type.toBeCallableWith("one");
     |                               ^
  42 |   });
  43 | 
  44 |   test("type expression can be called with provided argument", () => {

       at ./__typetests__/toBeCallableWith.test.ts:41:31 ❭ when target is a value ❭ type expression does not take arguments

Error: Type expression can be called with provided argument.

  44 |   test("type expression can be called with provided argument", () => {
  45 |     expect<(a: string) => string>().type.toBeCallableWith("one");
> 46 |     expect<(a: string) => string>().type.not.toBeCallableWith("one");
     |                                              ^
  47 |   });
  48 | 
  49 |   test("type expression requires 1 argument", () => {

       at ./__typetests__/toBeCallableWith.test.ts:46:46 ❭ when target is a value ❭ type expression can be called with provided argument

Error: Type expression requires 1 argument.

  49 |   test("type expression requires 1 argument", () => {
  50 |     expect<(a: string) => string>().type.not.toBeCallableWith();
> 51 |     expect<(a: string) => string>().type.toBeCallableWith();
     |                                          ^
  52 |   });
  53 | 
  54 |   test("type expression takes only 1 argument", () => {

       at ./__typetests__/toBeCallableWith.test.ts:51:42 ❭ when target is a value ❭ type expression requires 1 argument

Error: Type expression takes only 1 argument.

  54 |   test("type expression takes only 1 argument", () => {
  55 |     expect<(a: string) => string>().type.not.toBeCallableWith("one", "two");
> 56 |     expect<(a: string) => string>().type.toBeCallableWith("one", "two");
     |                                          ^
  57 |   });
  58 | });
  59 | 

       at ./__typetests__/toBeCallableWith.test.ts:56:42 ❭ when target is a value ❭ type expression takes only 1 argument

Error: Expression can be called without arguments.

  61 |   test("expression can be called without arguments", () => {
  62 |     expect(() => null).type.toBeCallableWith<[]>();
> 63 |     expect(() => null).type.not.toBeCallableWith<[]>();
     |                                 ^
  64 |   });
  65 | 
  66 |   test("expression does not take arguments", () => {

       at ./__typetests__/toBeCallableWith.test.ts:63:33 ❭ when target is a type ❭ expression can be called without arguments

Error: Expression does not take arguments.

  66 |   test("expression does not take arguments", () => {
  67 |     expect(() => null).type.not.toBeCallableWith<["one"]>();
> 68 |     expect(() => null).type.toBeCallableWith<["one"]>();
     |                             ^
  69 |   });
  70 | 
  71 |   test("expression can be called with provided argument", () => {

       at ./__typetests__/toBeCallableWith.test.ts:68:29 ❭ when target is a type ❭ expression does not take arguments

Error: Expression can be called with provided argument.

  71 |   test("expression can be called with provided argument", () => {
  72 |     expect((a: string) => a).type.toBeCallableWith<["one"]>();
> 73 |     expect((a: string) => a).type.not.toBeCallableWith<["one"]>();
     |                                       ^
  74 |   });
  75 | 
  76 |   test("expression requires 1 argument", () => {

       at ./__typetests__/toBeCallableWith.test.ts:73:39 ❭ when target is a type ❭ expression can be called with provided argument

Error: Expression requires 1 argument.

  76 |   test("expression requires 1 argument", () => {
  77 |     expect((a: string) => a).type.not.toBeCallableWith<[]>();
> 78 |     expect((a: string) => a).type.toBeCallableWith<[]>();
     |                                   ^
  79 |   });
  80 | 
  81 |   test("expression takes only 1 argument", () => {

       at ./__typetests__/toBeCallableWith.test.ts:78:35 ❭ when target is a type ❭ expression requires 1 argument

Error: Expression takes only 1 argument.

  81 |   test("expression takes only 1 argument", () => {
  82 |     expect((a: string) => a).type.not.toBeCallableWith<["one", "two"]>();
> 83 |     expect((a: string) => a).type.toBeCallableWith<["one", "two"]>();
     |                                   ^
  84 |   });
  85 | 
  86 |   test("type expression can be called without arguments", () => {

       at ./__typetests__/toBeCallableWith.test.ts:83:35 ❭ when target is a type ❭ expression takes only 1 argument

Error: Type expression can be called without arguments.

  86 |   test("type expression can be called without arguments", () => {
  87 |     expect<() => null>().type.toBeCallableWith<[]>();
> 88 |     expect<() => null>().type.not.toBeCallableWith<[]>();
     |                                   ^
  89 |   });
  90 | 
  91 |   test("type expression does not take arguments", () => {

       at ./__typetests__/toBeCallableWith.test.ts:88:35 ❭ when target is a type ❭ type expression can be called without arguments

Error: Type expression does not take arguments.

  91 |   test("type expression does not take arguments", () => {
  92 |     expect<() => null>().type.not.toBeCallableWith<["one"]>();
> 93 |     expect<() => null>().type.toBeCallableWith<["one"]>();
     |                               ^
  94 |   });
  95 | 
  96 |   test("type expression can be called with provided argument", () => {

       at ./__typetests__/toBeCallableWith.test.ts:93:31 ❭ when target is a type ❭ type expression does not take arguments

Error: Type expression can be called with provided argument.

   96 |   test("type expression can be called with provided argument", () => {
   97 |     expect<(a: string) => string>().type.toBeCallableWith<["one"]>();
>  98 |     expect<(a: string) => string>().type.not.toBeCallableWith<["one"]>();
      |                                              ^
   99 |   });
  100 | 
  101 |   test("type expression requires 1 argument", () => {

        at ./__typetests__/toBeCallableWith.test.ts:98:46 ❭ when target is a type ❭ type expression can be called with provided argument

Error: Type expression requires 1 argument.

  101 |   test("type expression requires 1 argument", () => {
  102 |     expect<(a: string) => string>().type.not.toBeCallableWith<[]>();
> 103 |     expect<(a: string) => string>().type.toBeCallableWith<[]>();
      |                                          ^
  104 |   });
  105 | 
  106 |   test("type expression takes only 1 argument", () => {

        at ./__typetests__/toBeCallableWith.test.ts:103:42 ❭ when target is a type ❭ type expression requires 1 argument

Error: Type expression takes only 1 argument.

  106 |   test("type expression takes only 1 argument", () => {
  107 |     expect<(a: string) => string>().type.not.toBeCallableWith<["one", "two"]>();
> 108 |     expect<(a: string) => string>().type.toBeCallableWith<["one", "two"]>();
      |                                          ^
  109 |   });
  110 | });
  111 | 

        at ./__typetests__/toBeCallableWith.test.ts:108:42 ❭ when target is a type ❭ type expression takes only 1 argument

"
`;

exports[`toBeCallableWith: stdout 1`] = `
"uses TypeScript <<version>> with ./tsconfig.json

fail ./__typetests__/toBeCallableWith.test.ts
  when target is a value
    × expression can be called without arguments
    × expression does not take arguments
    × expression can be called with provided argument
    × expression requires 1 argument
    × expression takes only 1 argument
    × type expression can be called without arguments
    × type expression does not take arguments
    × type expression can be called with provided argument
    × type expression requires 1 argument
    × type expression takes only 1 argument
  when target is a type
    × expression can be called without arguments
    × expression does not take arguments
    × expression can be called with provided argument
    × expression requires 1 argument
    × expression takes only 1 argument
    × type expression can be called without arguments
    × type expression does not take arguments
    × type expression can be called with provided argument
    × type expression requires 1 argument
    × type expression takes only 1 argument

Targets:    1 failed, 1 total
Test files: 1 failed, 1 total
Tests:      20 failed, 20 total
Assertions: 20 failed, 20 passed, 40 total
Duration:   <<timestamp>>

Ran all test files.
"
`;
